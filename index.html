<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåä Matrix Rain - Advanced Visual Control Unit</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff41;
            overflow-x: hidden;
        }

        .matrix-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60vw;
            max-width: 900px;
            height: 90vh;
            background: rgba(0, 0, 0, 0.85);
            border: 3px solid #00ff41;
            border-radius: 15px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.3);
        }

        .matrix-modal.minimized {
            top: 20px !important;
            left: auto !important;
            right: 20px !important;
            transform: none !important;
            width: 350px !important;
            height: 48px !important;
            min-width: 200px;
            border-radius: 12px !important;
            box-shadow: 0 2px 12px rgba(0,255,65,0.15);
            overflow: hidden;
        }

        .modal-header {
            background: linear-gradient(90deg, #00ff41, #00cc33);
            color: #000;
            padding: 15px 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
        }

        .close-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .minimize-btn {
            background: #ffaa00;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
        }

        .matrix-modal.minimized {
            height: 60px;
            overflow: hidden;
        }

        .matrix-modal.minimized .modal-content {
            display: none;
        }

        .matrix-modal.minimized .close-btn {
            display: none;
        }

        .matrix-modal.minimized .full-header-text {
            display: none;
        }

        .matrix-modal:not(.minimized) .minimized-header-text {
            display: none;
        }

        .modal-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: block;
        }

        .section {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff41;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .section h3 {
            color: #00ff41;
            margin-bottom: 15px;
            font-size: 16px;
            border-bottom: 2px solid #00ff41;
            padding-bottom: 5px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-connected { background: #00ff41; }
        .status-warning { background: #ffaa00; }
        .status-error { background: #ff4444; }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .rain-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 15px;
        }

        .control-group h4 {
            color: #00ff41;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .control-item {
            margin-bottom: 10px;
        }

        .control-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }

        .control-item input[type="range"] {
            width: 100%;
            background: #333;
            border-radius: 5px;
            outline: none;
        }

        .control-item input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .control-item select {
            width: 100%;
            background: #333;
            color: #00ff41;
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 5px;
            font-size: 12px;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .pattern-btn {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 10px;
            color: #00ff41;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .pattern-btn:hover {
            background: rgba(0, 255, 65, 0.2);
            transform: translateY(-2px);
        }

        .pattern-btn.active {
            background: #00ff41;
            color: #000;
        }

        .rainbow-spectrum {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .spectrum-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .spectrum-color:hover {
            transform: scale(1.2);
        }

        .spectrum-color.active {
            border-color: #fff;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .metric-card {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff41;
        }

        .metric-label {
            font-size: 12px;
            color: #ccc;
            margin-top: 5px;
        }

        .activity-feed {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 10px;
        }

        .activity-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
            font-size: 12px;
        }

        .audit-canvas {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }

        .audit-entry {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
        }

        .btn {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
        }

        .btn:hover {
            background: #00cc33;
        }

        .btn:disabled {
            background: rgba(100, 100, 100, 0.3);
            color: rgba(150, 150, 150, 0.5);
            cursor: not-allowed;
            opacity: 0.4;
        }

        .btn:disabled:hover {
            background: rgba(100, 100, 100, 0.3);
            transform: none;
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .btn-warning {
            background: #ffaa00;
            color: #000;
        }

        .toolkit-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .toolkit-card {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .toolkit-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.3);
        }

        .toolkit-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .toolkit-icon {
            font-size: 20px;
            margin-right: 10px;
        }

        .toolkit-name {
            font-weight: bold;
            color: #00ff41;
        }

        .toolkit-status {
            font-size: 12px;
            color: #00ff41;
            margin-left: auto;
        }

        .function-list {
            list-style: none;
            margin: 10px 0;
        }

        .function-list li {
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
            font-size: 12px;
        }

        .sample-analysis {
            background: rgba(0, 255, 65, 0.1);
            border: 1px solid #00ff41;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #00ff41;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #00cc33;
        }

        .file-upload-zone {
            background: rgba(0, 0, 0, 0.8);
            border: 2px dashed #00ff41;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .file-upload-zone:hover {
            background: rgba(0, 255, 65, 0.1);
            border-color: #00cc33;
        }

        .file-upload-zone.dragover {
            background: rgba(0, 255, 65, 0.2);
            border-color: #ffff00;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .playlist-container {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .playlist-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.2);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .playlist-item:hover {
            background: rgba(0, 255, 65, 0.1);
        }

        .playlist-item.playing {
            background: rgba(0, 255, 65, 0.2);
            border-left: 4px solid #00ff41;
        }

        .playlist-item-info {
            flex: 1;
            min-width: 0;
        }

        .playlist-item-title {
            color: #00ff41;
            font-weight: bold;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-item-duration {
            color: #999;
            font-size: 12px;
        }

        .playlist-item-remove {
            background: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 10px;
        }

        .playlist-item-remove:hover {
            background: #cc0000;
        }

        .player-controls {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            border-radius: 8px;
            padding: 20px;
        }

        .now-playing {
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 65, 0.3);
        }

        .now-playing-title {
            color: #00ff41;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .now-playing-time {
            color: #999;
            font-size: 12px;
        }

        .progress-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 3px;
            margin: 10px 0;
            cursor: pointer;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: #00ff41;
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .playback-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        .player-btn {
            background: #00ff41;
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .player-btn:hover {
            background: #00cc33;
            transform: scale(1.05);
        }

        .player-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .player-btn-primary {
            background: #ff1493;
            color: white;
            font-size: 20px;
            padding: 15px 30px;
        }

        .player-btn-primary:hover {
            background: #ff006f;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .volume-icon {
            font-size: 20px;
            color: #00ff41;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ff41;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ff41;
            cursor: pointer;
            border: none;
        }

        .playlist-stats {
            text-align: center;
            padding: 10px;
            color: #999;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <!-- Matrix Rain Canvas - Dual Layer System -->
    <canvas id="matrixRainCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; opacity: 0.8; background: transparent;"></canvas>
    <!-- Ollama Message Layer (appears on top when active) -->
    <canvas id="ollamaMessageCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; opacity: 1.0; background: transparent; display: none;"></canvas>

    <div class="matrix-modal scrollbar minimized">
        <div class="modal-header">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 10px;">
                <div class="minimized-header-text" style="flex: 1; min-width: 0; overflow: hidden;">
                    <span style="font-size: 16px; color: #ffff00; font-weight: bold;">üëâ CLICK</span>
                    <span style="font-size: 20px; color: #ff0000; font-weight: bold;">‚Üí‚Üí</span>
                </div>
                <div class="full-header-text" style="flex: 1; min-width: 0;">
                    üåä Matrix Rain
                    <span class="status-indicator status-connected"></span>
                    <span style="font-size: 12px; color: #000;">Connected</span>
                    <br>
                    <span style="font-size: 14px; color: #ff0000; padding: 2px 6px; background: rgba(255,255,0,0.3); border-radius: 4px; font-weight: bold;">‚å®Ô∏è Press M</span>
                </div>
                <div style="display: flex; gap: 5px; flex-shrink: 0;">
                    <button class="minimize-btn" onclick="toggleMatrixModal()" id="minimizeBtn">‚àí</button>
                    <button class="close-btn" onclick="closeMatrixModal()">√ó</button>
                </div>
            </div>
        </div>

        <div class="modal-content scrollbar">
            <!-- Left Column -->
            <div>
                <!-- Rain Pattern Controls -->
                <div class="section">
                    <h3>üåßÔ∏è Rain Pattern Controls</h3>
                    <div style="margin-bottom: 15px; text-align: center;">
                        <button class="btn" onclick="toggleMatrixRain()" style="background: #00ff41; color: black; font-weight: bold; font-size: 16px; padding: 12px 24px;">
                            üåä Toggle Matrix Rain
                        </button>
                        <button class="btn btn-danger" onclick="emergencyStop()" style="margin-left: 10px;">
                            üõë Emergency Stop
                        </button>
                        <button class="btn" id="reverseFlowBtn" onclick="toggleReverseFlow()" style="background: #ffaa00; color: black; font-weight: bold; font-size: 16px; padding: 12px 24px; margin-left: 10px;">
                            ‚è™ REVERSE FLOW
                        </button>
                    </div>
                    <div style="margin-bottom: 15px; text-align: center;">
                        <button class="btn" onclick="activateChaosRandomizer()" style="background: #ff00ff; color: black; font-weight: bold; font-size: 16px; padding: 12px 24px;">
                            üåÄ CHAOS ONCE
                        </button>
                        <button class="btn" id="autoOrchestratorBtn" onclick="toggleAutoOrchestrator()" style="background: #0080ff; color: white; font-weight: bold; font-size: 16px; padding: 12px 24px; margin-left: 10px;">
                            üé≠ AUTO ORCHESTRATOR
                        </button>
                    </div>
                    <div style="margin-bottom: 15px; text-align: center;">
                        <button class="btn" id="audioReactiveBtn" onclick="toggleAudioReactive()" style="background: #ff1493; color: white; font-weight: bold; font-size: 16px; padding: 12px 24px;">
                            üéµ AUDIO REACTIVE MODE
                        </button>
                        <button class="btn" id="ollamaModeBtn" onclick="toggleOllamaMode()" style="background: #00ffff; color: black; font-weight: bold; font-size: 16px; padding: 12px 24px; margin-left: 10px;">
                            üåÄ OLLAMA MODE
                        </button>
                        <div id="audioStatus" style="margin-top: 10px; font-size: 12px; color: #00ff41;"></div>
                        <div id="ollamaStatus" style="margin-top: 10px; font-size: 12px; color: #00ffff;"></div>
                        <div id="audioVisualizer" style="margin-top: 10px; height: 60px; background: rgba(0,0,0,0.5); border: 1px solid #00ff41; border-radius: 5px; position: relative; overflow: hidden;"></div>
                    </div>
                    <div class="pattern-grid">
                        <button class="pattern-btn active" onclick="setRainPattern('classic', this)">Classic Matrix</button>
                        <button class="pattern-btn" onclick="setRainPattern('rainbow', this)">Rainbow Spectrum</button>
                        <button class="pattern-btn" onclick="setRainPattern('pentad', this)">Pentad Prism</button>
                        <button class="pattern-btn" onclick="setRainPattern('chaos', this)">Chaos Flow</button>
                        <button class="pattern-btn" onclick="setRainPattern('harmonic', this)">Harmonic Waves</button>
                        <button class="pattern-btn" onclick="setRainPattern('particles', this)">üí´ Particles</button>
                    </div>
                </div>

                <!-- Visual Controls -->
                <div class="section">
                    <h3>üé® Visual Controls</h3>
                    <div class="rain-controls">
                        <div class="control-group">
                            <h4>Speed & Intensity</h4>
                            <div class="control-item">
                                <label>Rain Speed</label>
                                <input type="range" id="rainSpeed" min="1" max="100" value="35" onchange="updateRainSpeed()">
                            </div>
                            <div class="control-item">
                                <label>Intensity</label>
                                <input type="range" id="rainIntensity" min="1" max="100" value="70" onchange="updateRainIntensity()">
                            </div>
                            <div class="control-item">
                                <label>Density</label>
                                <input type="range" id="rainDensity" min="1" max="100" value="50" onchange="updateRainDensity()">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Colors & Effects</h4>
                            <div class="control-item">
                                <label>Primary Color</label>
                                <input type="color" id="primaryColor" value="#00ff41" onchange="updateRainColors()">
                            </div>
                            <div class="control-item">
                                <label>Secondary Color</label>
                                <input type="color" id="secondaryColor" value="#00cc33" onchange="updateRainColors()">
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Rainbow Spectrum</h4>
                            <div class="rainbow-spectrum">
                                <div class="spectrum-color active" style="background: #ff0000;" onclick="setSpectrumColor('#ff0000', this)"></div>
                                <div class="spectrum-color" style="background: #ff8000;" onclick="setSpectrumColor('#ff8000', this)"></div>
                                <div class="spectrum-color" style="background: #ffff00;" onclick="setSpectrumColor('#ffff00', this)"></div>
                                <div class="spectrum-color" style="background: #00ff00;" onclick="setSpectrumColor('#00ff00', this)"></div>
                                <div class="spectrum-color" style="background: #0080ff;" onclick="setSpectrumColor('#0080ff', this)"></div>
                                <div class="spectrum-color" style="background: #8000ff;" onclick="setSpectrumColor('#8000ff', this)"></div>
                                <div class="spectrum-color" style="background: #ff0080;" onclick="setSpectrumColor('#ff0080', this)"></div>
                            </div>
                        </div>

                        <div class="control-group">
                            <h4>Pattern Settings</h4>
                            <div class="control-item">
                                <label>Character Set</label>
                                <select id="characterSet" onchange="updateCharacterSet()">
                                    <option value="matrix">Matrix (A-Z, 0-9, @#$)</option>
                                    <option value="binary">Binary (01)</option>
                                    <option value="hex">Hexadecimal (0-F)</option>
                                    <option value="symbols">Symbols (@#$%^&*)</option>
                                    <option value="katakana">Katakana („Ç¢„Ç§„Ç¶„Ç®„Ç™...)</option>
                                    <option value="custom">Custom</option>
                                </select>
                                <input type="text" id="customCharacters" placeholder="Enter custom characters..." style="display: none; margin-top: 5px; padding: 5px; width: 100%; background: rgba(0,255,65,0.1); border: 1px solid #00ff41; color: #00ff41; font-family: monospace;" onchange="updateCharacterSet()">
                            </div>
                            <div class="control-item">
                                <label>Direction</label>
                                <select id="rainDirection" onchange="updateRainDirection()">
                                    <option value="down">Down</option>
                                    <option value="up">Up</option>
                                    <option value="left">Left</option>
                                    <option value="right">Right</option>
                                    <option value="diagonal">Diagonal</option>
                                    <option value="toward">üöá Toward Camera (3D)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column - Audio File Player -->
            <div>
                <!-- Audio File Player -->
                <div class="section audio-player-container">
                    <h3>üéµ Audio File Player</h3>
                    <p style="font-size: 12px; color: #999; margin-bottom: 15px;">Upload MP3/WAV files to sync visualizations without screen sharing. Works alongside tab sharing mode!</p>

                    <!-- File Upload Zone -->
                    <div class="file-upload-zone" id="fileUploadZone" onclick="document.getElementById('audioFileInput').click()">
                        <div class="upload-icon">üéµ</div>
                        <div style="color: #00ff41; font-weight: bold; margin-bottom: 5px;">Click to Select Audio Files</div>
                        <div style="color: #999; font-size: 12px;">Supports MP3, WAV, OGG, M4A</div>
                    </div>
                    <input type="file" id="audioFileInput" accept="audio/*" multiple style="display: none;" onchange="handleFileSelect(event)">

                    <!-- Playlist -->
                    <div class="section">
                        <h3 style="font-size: 14px; color: #00ff41; margin-bottom: 10px;">üìã Playlist</h3>
                        <div class="playlist-container scrollbar" id="playlistContainer">
                            <div class="playlist-stats" id="emptyPlaylist">
                                No tracks loaded. Upload some audio files!
                            </div>
                        </div>
                        <div class="playlist-stats" id="playlistStats" style="display: none;">
                            <span id="playlistCount">0</span> tracks | <span id="playlistDuration">0:00</span> total
                        </div>
                    </div>

                    <!-- Player Controls -->
                    <div class="player-controls">
                        <div class="now-playing" id="nowPlayingSection" style="display: none;">
                            <div class="now-playing-title" id="nowPlayingTitle">No track playing</div>
                            <div class="now-playing-time">
                                <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
                            </div>
                            <div class="progress-bar-container" onclick="seekAudio(event)">
                                <div class="progress-bar" id="progressBar"></div>
                            </div>
                        </div>

                        <div class="playback-buttons">
                            <button class="player-btn" onclick="previousTrack()" id="prevBtn" disabled>‚èÆÔ∏è Prev</button>
                            <button class="player-btn player-btn-primary" onclick="togglePlayPause()" id="playPauseBtn" disabled>‚ñ∂Ô∏è Play</button>
                            <button class="player-btn" onclick="nextTrack()" id="nextBtn" disabled>‚è≠Ô∏è Next</button>
                        </div>

                        <div class="playback-buttons">
                            <button class="player-btn" onclick="toggleShuffle()" id="shuffleBtn">üîÄ Shuffle</button>
                            <button class="player-btn" onclick="toggleRepeat()" id="repeatBtn">üîÅ Repeat</button>
                        </div>

                        <div class="volume-control">
                            <span class="volume-icon" id="volumeIcon">üîä</span>
                            <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70" oninput="updateVolume()">
                            <span style="color: #00ff41; font-size: 14px; min-width: 40px;" id="volumeDisplay">70%</span>
                        </div>

                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(0, 255, 65, 0.3);">
                            <button class="btn" id="fileAudioModeBtn" onclick="toggleFileAudioMode()" style="width: 100%; background: #ff1493; color: white; font-size: 16px; padding: 15px;" disabled>
                                üéµ START AUDIO VISUALIZATION
                            </button>
                            <div style="text-align: center; margin-top: 10px; font-size: 11px; color: #999;">
                                Start playing a track, then click to enable visualization mode
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Audio Info Section -->
                <div class="section">
                    <h3>‚ÑπÔ∏è Audio Modes</h3>
                    <div style="font-size: 12px; line-height: 1.6;">
                        <div style="margin-bottom: 10px; padding: 10px; background: rgba(0, 255, 65, 0.1); border-radius: 5px;">
                            <strong style="color: #00ff41;">üéµ File Player Mode</strong><br>
                            <span style="color: #999;">Upload your own audio files for visualization. Great for music libraries or offline use.</span>
                        </div>
                        <div style="padding: 10px; background: rgba(0, 255, 65, 0.1); border-radius: 5px;">
                            <strong style="color: #00ff41;">üñ•Ô∏è Tab Sharing Mode</strong><br>
                            <span style="color: #999;">Capture audio from browser tabs (YouTube, Spotify, etc). Great for streaming services.</span>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // === REVERSE FLOW CONTROL ===
        let reverseFlowMultiplier = 1; // 1 = normal, -1 = reversed

        // === MODE BUTTON MANAGEMENT - Prevent multiple modes at once ===
        function updateModeButtons(activeMode) {
            const orchestratorBtn = document.getElementById('autoOrchestratorBtn');
            const audioBtn = document.getElementById('audioReactiveBtn');
            const ollamaBtn = document.getElementById('ollamaModeBtn');

            // Reset all buttons to enabled
            orchestratorBtn.disabled = false;
            audioBtn.disabled = false;
            ollamaBtn.disabled = false;

            // Disable the other buttons based on active mode
            if (activeMode === 'orchestrator') {
                audioBtn.disabled = true;
                ollamaBtn.disabled = true;
            } else if (activeMode === 'audio') {
                orchestratorBtn.disabled = true;
                ollamaBtn.disabled = true;
            } else if (activeMode === 'ollama') {
                orchestratorBtn.disabled = true;
                audioBtn.disabled = true;
            }
            // If activeMode is null/undefined, all buttons remain enabled
        }

        // === AUDIO FILE PLAYER SYSTEM ===
        let audioPlayer = null;
        let playlist = [];
        let currentTrackIndex = -1;
        let isPlaying = false;
        let isShuffle = false;
        let isRepeat = false;
        let fileAudioContext = null;
        let fileAudioAnalyser = null;
        let fileAudioSource = null;
        let fileAudioDataArray = null;
        let fileAudioModeActive = false;
        let fileAudioAnimationFrame = null;

        // Initialize audio player element
        function initAudioPlayer() {
            if (!audioPlayer) {
                audioPlayer = new Audio();
                audioPlayer.addEventListener('ended', handleTrackEnd);
                audioPlayer.addEventListener('timeupdate', updateProgress);
                audioPlayer.addEventListener('loadedmetadata', updateTrackInfo);
                audioPlayer.volume = 0.7;
            }
        }

        // File Upload Handling
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            addFilesToPlaylist(files);
            event.target.value = ''; // Reset input
        }

        // Drag & Drop Disabled: prevent lag from accidental large drops
        (function disableDragDrop() {
            const uploadZone = document.getElementById('fileUploadZone');
            if (uploadZone) {
                // Remove any visual dragover state just in case
                uploadZone.classList.remove('dragover');
            }
            // Block drag/drop globally
            const stopAll = (e) => { e.preventDefault(); e.stopPropagation(); };
            ['dragenter','dragover','dragleave','drop'].forEach(evt => {
                window.addEventListener(evt, stopAll, true);
                document.addEventListener(evt, stopAll, true);
            });
        })();

        function addFilesToPlaylist(files) {
            initAudioPlayer();

            files.forEach((file, index) => {
                const url = URL.createObjectURL(file);
                const track = {
                    id: Date.now() + index,
                    name: file.name.replace(/\.[^/.]+$/, ''), // Remove extension
                    url: url,
                    file: file,
                    duration: 0
                };
                playlist.push(track);

                // Get duration
                const tempAudio = new Audio(url);
                tempAudio.addEventListener('loadedmetadata', () => {
                    track.duration = tempAudio.duration;
                    updatePlaylistDisplay();
                });
            });

            updatePlaylistDisplay();
            MatrixRainEngine.logActivity(`üéµ Added ${files.length} track(s) to playlist`, 'success');
        }

        function updatePlaylistDisplay() {
            const container = document.getElementById('playlistContainer');
            const stats = document.getElementById('playlistStats');

            if (!container || !stats) return;

            if (playlist.length === 0) {
                container.innerHTML = '<div class="playlist-stats" id="emptyPlaylist">No tracks loaded. Upload some audio files!</div>';
                stats.style.display = 'none';
                return;
            }

            // Update stats
            const playlistCount = document.getElementById('playlistCount');
            const playlistDuration = document.getElementById('playlistDuration');

            const totalDuration = playlist.reduce((sum, track) => sum + track.duration, 0);
            if (playlistCount) playlistCount.textContent = playlist.length;
            if (playlistDuration) playlistDuration.textContent = formatTime(totalDuration);

            stats.style.display = 'block';

            // Build playlist HTML
            container.innerHTML = playlist.map((track, index) => `
                <div class="playlist-item ${index === currentTrackIndex ? 'playing' : ''}" onclick="playTrack(${index})">
                    <div class="playlist-item-info">
                        <div class="playlist-item-title">
                            ${index === currentTrackIndex && isPlaying ? '‚ñ∂Ô∏è ' : ''}${track.name}
                        </div>
                        <div class="playlist-item-duration">${formatTime(track.duration)}</div>
                    </div>
                    <button class="playlist-item-remove" onclick="event.stopPropagation(); removeTrack(${index})">‚úï</button>
                </div>
            `).join('');
        }

        function removeTrack(index) {
            if (index === currentTrackIndex && isPlaying) {
                stopPlayback();
            }

            URL.revokeObjectURL(playlist[index].url);
            playlist.splice(index, 1);

            if (currentTrackIndex > index) {
                currentTrackIndex--;
            } else if (currentTrackIndex === index) {
                currentTrackIndex = -1;
            }

            updatePlaylistDisplay();
            MatrixRainEngine.logActivity('üóëÔ∏è Track removed from playlist', 'info');
        }

        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;

            initAudioPlayer();
            currentTrackIndex = index;
            const track = playlist[index];

            audioPlayer.src = track.url;
            audioPlayer.play();
            isPlaying = true;

            updatePlaylistDisplay();
            updateNowPlaying();
            updatePlayPauseButton();
            enableControls();

            MatrixRainEngine.logActivity(`üéµ Now playing: ${track.name}`, 'success');
        }

        function togglePlayPause() {
            if (!audioPlayer || playlist.length === 0) return;

            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
                MatrixRainEngine.logActivity('‚è∏Ô∏è Playback paused', 'info');
            } else {
                if (currentTrackIndex === -1) {
                    playTrack(0);
                } else {
                    audioPlayer.play();
                    isPlaying = true;
                    MatrixRainEngine.logActivity('‚ñ∂Ô∏è Playback resumed', 'success');
                }
            }

            updatePlayPauseButton();
            updatePlaylistDisplay();
        }

        function previousTrack() {
            if (playlist.length === 0) return;

            let newIndex = currentTrackIndex - 1;
            if (newIndex < 0) newIndex = playlist.length - 1;
            playTrack(newIndex);
        }

        function nextTrack() {
            if (playlist.length === 0) return;

            let newIndex;
            if (isShuffle) {
                newIndex = Math.floor(Math.random() * playlist.length);
            } else {
                newIndex = currentTrackIndex + 1;
                if (newIndex >= playlist.length) newIndex = 0;
            }
            playTrack(newIndex);
        }

        function handleTrackEnd() {
            if (isRepeat) {
                audioPlayer.currentTime = 0;
                audioPlayer.play();
            } else {
                nextTrack();
            }
        }

        function toggleShuffle() {
            isShuffle = !isShuffle;
            const btn = document.getElementById('shuffleBtn');
            if (isShuffle) {
                btn.style.background = '#00ff41';
                btn.style.color = '#000';
                MatrixRainEngine.logActivity('üîÄ Shuffle enabled', 'success');
            } else {
                btn.style.background = '#333';
                btn.style.color = '#00ff41';
                MatrixRainEngine.logActivity('üîÄ Shuffle disabled', 'info');
            }
        }

        function toggleRepeat() {
            isRepeat = !isRepeat;
            const btn = document.getElementById('repeatBtn');
            if (isRepeat) {
                btn.style.background = '#00ff41';
                btn.style.color = '#000';
                MatrixRainEngine.logActivity('üîÅ Repeat enabled', 'success');
            } else {
                btn.style.background = '#333';
                btn.style.color = '#00ff41';
                MatrixRainEngine.logActivity('üîÅ Repeat disabled', 'info');
            }
        }

        function updateVolume() {
            if (!audioPlayer) return;

            const volume = document.getElementById('volumeSlider').value;
            audioPlayer.volume = volume / 100;
            document.getElementById('volumeDisplay').textContent = volume + '%';

            // Update icon
            const icon = document.getElementById('volumeIcon');
            if (volume == 0) icon.textContent = 'üîá';
            else if (volume < 33) icon.textContent = 'üîà';
            else if (volume < 66) icon.textContent = 'üîâ';
            else icon.textContent = 'üîä';
        }

        function updateProgress() {
            if (!audioPlayer) return;

            const currentTime = audioPlayer.currentTime;
            const duration = audioPlayer.duration || 0;
            const progress = (currentTime / duration) * 100;

            document.getElementById('progressBar').style.width = progress + '%';
            document.getElementById('currentTime').textContent = formatTime(currentTime);
        }

        function seekAudio(event) {
            if (!audioPlayer || !audioPlayer.duration) return;

            const bar = event.currentTarget;
            const rect = bar.getBoundingClientRect();
            const percent = (event.clientX - rect.left) / rect.width;
            audioPlayer.currentTime = percent * audioPlayer.duration;
        }

        function updateNowPlaying() {
            const section = document.getElementById('nowPlayingSection');
            const title = document.getElementById('nowPlayingTitle');
            const totalTime = document.getElementById('totalTime');

            if (currentTrackIndex >= 0 && playlist[currentTrackIndex]) {
                section.style.display = 'block';
                title.textContent = playlist[currentTrackIndex].name;
                totalTime.textContent = formatTime(playlist[currentTrackIndex].duration);
            } else {
                section.style.display = 'none';
            }
        }

        function updateTrackInfo() {
            updateNowPlaying();
        }

        function updatePlayPauseButton() {
            const btn = document.getElementById('playPauseBtn');
            if (isPlaying) {
                btn.textContent = '‚è∏Ô∏è Pause';
            } else {
                btn.textContent = '‚ñ∂Ô∏è Play';
            }
        }

        function enableControls() {
            document.getElementById('playPauseBtn').disabled = false;
            document.getElementById('prevBtn').disabled = false;
            document.getElementById('nextBtn').disabled = false;
            document.getElementById('fileAudioModeBtn').disabled = false;
        }

        function stopPlayback() {
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
            }
            isPlaying = false;
            updatePlayPauseButton();
            updatePlaylistDisplay();
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // === FILE AUDIO VISUALIZATION MODE ===
        async function toggleFileAudioMode() {
            console.log('üéµ toggleFileAudioMode called! Current state:', fileAudioModeActive);
            console.log('Audio player exists:', !!audioPlayer);
            console.log('Is playing:', isPlaying);

            const btn = document.getElementById('fileAudioModeBtn');
            fileAudioModeActive = !fileAudioModeActive;

            if (fileAudioModeActive) {
                // Stop tab sharing mode if active
                if (audioReactiveActive) {
                    console.log('‚ö†Ô∏è Stopping tab sharing mode first...');
                    await toggleAudioReactive();
                }

                btn.textContent = '‚è∏Ô∏è STOP VISUALIZATION';
                btn.style.background = '#ff4444';

                try {
                    // Set up Web Audio API for file - ONLY if not already set up
                    if (!fileAudioContext || fileAudioContext.state === 'closed') {
                        console.log('‚úÖ Creating new audio context...');
                        fileAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                        fileAudioAnalyser = fileAudioContext.createAnalyser();
                        fileAudioAnalyser.fftSize = 2048;
                        fileAudioAnalyser.smoothingTimeConstant = 0.2; // REDUCED from 0.5 for ultra-responsive color changes!

                        // Connect audio player to analyzer - ONLY ONCE
                        if (!fileAudioSource) {
                            console.log('‚úÖ Creating media element source and connecting...');
                            fileAudioSource = fileAudioContext.createMediaElementSource(audioPlayer);
                            fileAudioSource.connect(fileAudioAnalyser);
                            fileAudioAnalyser.connect(fileAudioContext.destination);
                        }

                        fileAudioDataArray = new Uint8Array(fileAudioAnalyser.frequencyBinCount);
                    } else {
                        console.log('‚úÖ Reusing existing audio context, state:', fileAudioContext.state);
                        // Resume context if suspended
                        if (fileAudioContext.state === 'suspended') {
                            console.log('‚ö†Ô∏è Resuming suspended context...');
                            await fileAudioContext.resume();
                        }
                    }

                    // Force Classic pattern for audio mode
                    console.log('‚úÖ Setting rain pattern to classic...');
                    setRainPattern('classic');

                    // Gray out secondary color picker (not used in audio mode)
                    const secondaryColorPicker = document.getElementById('secondaryColor');
                    const secondaryColorLabel = secondaryColorPicker.previousElementSibling;
                    if (secondaryColorPicker) {
                        secondaryColorPicker.style.opacity = '0.3';
                        secondaryColorPicker.style.pointerEvents = 'none';
                        secondaryColorPicker.style.filter = 'grayscale(100%)';
                        secondaryColorPicker.disabled = true;
                    }
                    if (secondaryColorLabel) {
                        secondaryColorLabel.style.opacity = '0.5';
                    }

                    console.log('‚úÖ Starting audio analysis loop...');
                    MatrixRainEngine.logActivity('üéµ File Audio Visualization ACTIVATED', 'success');
                    analyzeFileAudio();
                    console.log('üéâ VISUALIZATION STARTED! Watch the rain!');

                } catch (error) {
                    console.error('‚ùå File audio setup error:', error);
                    console.error('Error details:', error.message, error.name);
                    fileAudioModeActive = false;
                    btn.textContent = 'üéµ START AUDIO VISUALIZATION';
                    btn.style.background = '#ff1493';

                    // Re-enable secondary color picker on error
                    const secondaryColorPicker = document.getElementById('secondaryColor');
                    const secondaryColorLabel = secondaryColorPicker.previousElementSibling;
                    if (secondaryColorPicker) {
                        secondaryColorPicker.style.opacity = '1';
                        secondaryColorPicker.style.pointerEvents = 'auto';
                        secondaryColorPicker.style.filter = 'none';
                        secondaryColorPicker.disabled = false;
                    }
                    if (secondaryColorLabel) {
                        secondaryColorLabel.style.opacity = '1';
                    }

                    alert('Error starting visualization: ' + error.message);
                }

            } else {
                console.log('‚è∏Ô∏è Stopping visualization...');
                btn.textContent = 'üéµ START AUDIO VISUALIZATION';
                btn.style.background = '#ff1493';
                stopFileAudioMode();

                // Re-enable secondary color picker
                const secondaryColorPicker = document.getElementById('secondaryColor');
                const secondaryColorLabel = secondaryColorPicker.previousElementSibling;
                if (secondaryColorPicker) {
                    secondaryColorPicker.style.opacity = '1';
                    secondaryColorPicker.style.pointerEvents = 'auto';
                    secondaryColorPicker.style.filter = 'none';
                    secondaryColorPicker.disabled = false;
                }
                if (secondaryColorLabel) {
                    secondaryColorLabel.style.opacity = '1';
                }

                MatrixRainEngine.logActivity('üéµ File Audio Visualization STOPPED', 'info');
            }
        }

        function stopFileAudioMode() {
            if (fileAudioAnimationFrame) {
                cancelAnimationFrame(fileAudioAnimationFrame);
                fileAudioAnimationFrame = null;
            }
            // Note: We don't close the context because it's connected to the audio player
            // The audio player needs to keep working for playback
            fileAudioAnalyser = null;
        }

        function analyzeFileAudio() {
            if (!fileAudioModeActive || !fileAudioAnalyser) return;

            fileAudioAnimationFrame = requestAnimationFrame(analyzeFileAudio);

            // Get frequency data
            fileAudioAnalyser.getByteFrequencyData(fileAudioDataArray);

            // Use the same index ranges as tab audio reactive mode
            const len = fileAudioDataArray.length;
            const avgRange = (start, end) => {
                let sum = 0, count = 0;
                for (let i = start; i < end && i < len; i++) { sum += fileAudioDataArray[i]; count++; }
                return count > 0 ? sum / count : 0;
            };
            const bass = avgRange(0, 80);        // 0-80 bins
            const lowMid = avgRange(80, 200);    // 80-200 bins
            const mid = avgRange(200, 600);      // 200-600 bins
            const high = avgRange(600, 1024);    // 600-1024 bins

            // Calculate overall volume (RMS-like average)
            let sum = 0;
            for (let i = 0; i < len; i++) { sum += fileAudioDataArray[i]; }
            const avgVolume = sum / len;
            const normalizedVolume = avgVolume / 255; // 0-1

            // Mirror tab audio reactive behavior exactly
            const volume = (bass + lowMid + mid + high) / 4 / 255;

            // Syllables/consonants/vocals trigger reverse flow exactly like tab mode
            detectSyllables(volume, mid, high);
            // Optional: beat backup (keep consistent with tab mode usage)
            // detectBeats(bass);

            // Use the same intelligent mapping as tab audio mode
            reactToAudio(bass, lowMid, mid, high, volume);

            // Update visualizer bars
            drawAudioVisualizer(bass, lowMid, mid, high);
        }

        // Helper function to convert HSL to Hex
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        // === MATRIX RAIN ADVANCED VISUAL CONTROL ENGINE ===
        const MatrixRainEngine = {
            // Rain configuration
            rainConfig: {
                pattern: 'classic',
                speed: 35,
                intensity: 70,
                density: 50,
                primaryColor: '#00ff41',
                secondaryColor: '#00cc33',
                fontSize: 10,
                characterSet: 'matrix',
                direction: 'down',
                spectrumColor: '#ff0000'
            },
            
            // Pattern definitions
            patterns: {
                classic: {
                    name: 'Classic Matrix',
                    description: 'Traditional matrix rain effect',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'down'
                },
                reverse: {
                    name: 'Reverse Flow',
                    description: 'Matrix rain flowing upward',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'up'
                },
                sideways: {
                    name: 'Sideways Flow',
                    description: 'Matrix rain flowing horizontally',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'left'
                },
                bidirectional: {
                    name: 'Bidirectional',
                    description: 'Matrix rain flowing in two directions',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'bidirectional'
                },
                quadirectional: {
                    name: 'Quadirectional',
                    description: 'Matrix rain flowing in four directions',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'quadirectional'
                },
                interdimensional: {
                    name: 'Interdimensional',
                    description: 'Multi-dimensional matrix rain',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'interdimensional'
                },
                rainbow: {
                    name: 'Rainbow Spectrum',
                    description: 'Rainbow-colored matrix rain',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'down',
                    colors: ['#ff0000', '#ff8000', '#ffff00', '#00ff00', '#0080ff', '#8000ff', '#ff0080']
                },
                pentad: {
                    name: 'Pentad Prism',
                    description: 'Five-dimensional prism effect',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'pentad'
                },
                chaos: {
                    name: 'Chaos Flow',
                    description: 'Chaotic matrix rain patterns',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'chaos'
                },
                harmonic: {
                    name: 'Harmonic Waves',
                    description: 'Harmonically synchronized rain',
                    characters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}',
                    direction: 'harmonic'
                }
            },
            
            // === LOGGING FUNCTIONS ===
            logActivity(message, type = 'info') {
                console.log(`üåä Matrix Rain: ${message}`);
                try {
                    this.addActivity(message, type === 'success');
                    this.addAuditEntry(`[üåä Matrix Rain] ${message}`);
                } catch (error) {
                    console.log(`üåä Matrix Rain: ${message} (UI elements not ready)`);
                }
            },

            // === PATTERN CONTROL FUNCTIONS ===
            setRainPattern(pattern, buttonElement) {
                console.log(`üåä Matrix Rain: Setting pattern to ${pattern}`);

                // Update active button
                document.querySelectorAll('.pattern-btn').forEach(btn => btn.classList.remove('active'));
                if (buttonElement) {
                    buttonElement.classList.add('active');
                }

                this.rainConfig.pattern = pattern;
                const patternData = this.patterns[pattern];

                this.addActivity(`üåßÔ∏è Rain pattern changed to: ${patternData.name}`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üåßÔ∏è Pattern changed: ${patternData.name} - ${patternData.description}`);

                // Apply pattern-specific settings
                this.applyPatternSettings(pattern);

                return `Pattern set to: ${patternData.name}`;
            },

            applyPatternSettings(pattern) {
                const patternData = this.patterns[pattern];
                
                // Update character set
                if (patternData.characters) {
                    this.rainConfig.characterSet = patternData.characters;
                    document.getElementById('characterSet').value = 'custom';
                }
                
                // Update direction
                if (patternData.direction) {
                    this.rainConfig.direction = patternData.direction;
                    document.getElementById('rainDirection').value = patternData.direction;
                }
                
                // Apply special effects
                if (pattern === 'rainbow') {
                    this.applyRainbowEffect();
                } else if (pattern === 'pentad') {
                    this.applyPentadEffect();
                } else if (pattern === 'chaos') {
                    this.applyChaosEffect();
                } else if (pattern === 'harmonic') {
                    this.applyHarmonicEffect();
                }
            },

            applyRainbowEffect() {
                console.log("üåà Applying rainbow spectrum effect...");
                this.addActivity("üåà Rainbow spectrum effect applied", true);
                this.addAuditEntry("[üåä Matrix Rain] üåà Rainbow spectrum effect activated");
            },

            applyPentadEffect() {
                console.log("üîÆ Applying pentad prism effect...");
                this.addActivity("üîÆ Pentad prism effect applied", true);
                this.addAuditEntry("[üåä Matrix Rain] üîÆ Pentad prism effect activated");
            },

            applyChaosEffect() {
                console.log("üåÄ Applying chaos flow effect...");
                this.addActivity("üåÄ Chaos flow effect applied", true);
                this.addAuditEntry("[üåä Matrix Rain] üåÄ Chaos flow effect activated");
            },

            applyHarmonicEffect() {
                console.log("üéµ Applying harmonic wave effect...");
                this.addActivity("üéµ Harmonic wave effect applied", true);
                this.addAuditEntry("[üåä Matrix Rain] üéµ Harmonic wave effect activated");
            },

            // === VISUAL CONTROL FUNCTIONS ===
            updateRainSpeed() {
                const speed = document.getElementById('rainSpeed').value;
                this.rainConfig.speed = parseInt(speed);
                this.addActivity(`‚ö° Rain speed updated to: ${speed}`, true);
                this.addAuditEntry(`[üåä Matrix Rain] ‚ö° Speed updated: ${speed}`);
            },

            updateRainIntensity() {
                const intensity = document.getElementById('rainIntensity').value;
                this.rainConfig.intensity = parseInt(intensity);
                this.addActivity(`üî• Rain intensity updated to: ${intensity}%`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üî• Intensity updated: ${intensity}%`);
            },

            updateRainDensity() {
                const density = document.getElementById('rainDensity').value;
                this.rainConfig.density = parseInt(density);
                this.addActivity(`üåßÔ∏è Rain density updated to: ${density}%`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üåßÔ∏è Density updated: ${density}%`);
            },

            updateRainColors() {
                const primary = document.getElementById('primaryColor').value;
                const secondary = document.getElementById('secondaryColor').value;
                this.rainConfig.primaryColor = primary;
                this.rainConfig.secondaryColor = secondary;
                this.addActivity(`üé® Colors updated: Primary ${primary}, Secondary ${secondary}`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üé® Colors updated: Primary ${primary}, Secondary ${secondary}`);
            },


            updateFontSize() {
                const fontSize = document.getElementById('fontSize').value;
                this.rainConfig.fontSize = parseInt(fontSize);
                this.addActivity(`üìù Font size updated to: ${fontSize}px`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üìù Font size updated: ${fontSize}px`);
            },

            updateCharacterSet() {
                const characterSet = document.getElementById('characterSet').value;
                this.rainConfig.characterSet = characterSet;
                this.addActivity(`üî§ Character set updated to: ${characterSet}`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üî§ Character set updated: ${characterSet}`);
            },

            updateRainDirection() {
                const direction = document.getElementById('rainDirection').value;
                const oldDirection = this.rainConfig.direction;
                this.rainConfig.direction = direction;

                // Reinitialize drop positions when switching to/from horizontal
                if (matrixCanvas && matrixDrops) {
                    const fontSize = this.rainConfig.fontSize;
                    const wasHorizontal = (oldDirection === 'left' || oldDirection === 'right');
                    const isHorizontal = (direction === 'left' || direction === 'right');

                    if (wasHorizontal !== isHorizontal) {
                        // Switching orientation - reinitialize all drops
                        const columns = Math.floor(matrixCanvas.width / fontSize);
                        for (let i = 0; i < columns; i++) {
                            if (isHorizontal) {
                                // Going horizontal: randomize X positions across full width
                                matrixDrops[i] = Math.random() * (matrixCanvas.width / fontSize);
                            } else {
                                // Going vertical: randomize Y positions across full height
                                matrixDrops[i] = Math.random() * (matrixCanvas.height / fontSize);
                            }
                        }
                    }
                }

                this.addActivity(`‚û°Ô∏è Rain direction updated to: ${direction}`, true);
                this.addAuditEntry(`[üåä Matrix Rain] ‚û°Ô∏è Direction updated: ${direction}`);
            },

            setSpectrumColor(color, colorElement) {
                document.querySelectorAll('.spectrum-color').forEach(btn => btn.classList.remove('active'));
                if (colorElement) {
                    colorElement.classList.add('active');
                }
                this.rainConfig.primaryColor = color;
                this.rainConfig.secondaryColor = color;
                this.addActivity(`üåà Spectrum color set to: ${color}`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üåà Spectrum color: ${color}`);
            },

            // === TOOLKIT INTEGRATION FUNCTIONS ===
            activatePatternAnalysis() {
                const result = toolkits.kleene.functions.analyzeRecursiveConvergence("matrix_patterns");
                MatrixRainEngine.logActivity(result, 'info');
                document.getElementById('kleene-result').textContent = result;
            },

            resurrectVisualData() {
                const result = toolkits.phoenix.functions.resurrectData("visual_data");
                MatrixRainEngine.logActivity(result, 'info');
                document.getElementById('phoenix-result').textContent = result;
            },

            harmonizePatterns() {
                const result = toolkits.harmonic.functions.integratePatterns("matrix_patterns");
                MatrixRainEngine.logActivity(result, 'info');
                document.getElementById('harmonic-result').textContent = result;
            },

            createEchoChamber() {
                const result = toolkits.breath.functions.createEchoChamber("matrix_echoes");
                MatrixRainEngine.logActivity(result, 'info');
                document.getElementById('breath-result').textContent = result;
            },

            interpretSymbols() {
                const result = toolkits.symbolic.functions.interpretArchetypalSymbol("matrix");
                MatrixRainEngine.logActivity(result, 'info');
                document.getElementById('symbolic-result').textContent = result;
            },

            optimizeFlow() {
                console.log("‚ö° Matrix Rain: Optimizing flow...");
                
                const optimization = Math.floor(Math.random() * 20) + 80;
                const efficiency = Math.floor(Math.random() * 15) + 85;
                
                this.addActivity(`‚ö° Flow optimization: ${optimization}% optimized, ${efficiency}% efficient`, true);
                this.addAuditEntry(`[üåä Matrix Rain] ‚ö° Flow optimization: ${optimization}% optimized, ${efficiency}% efficient`);
                
                return `Flow optimization: ${optimization}% optimized, ${efficiency}% efficient`;
            },

            backupVisualState() {
                console.log("üíæ Matrix Rain: Backing up visual state...");
                
                const backupSize = Math.floor(Math.random() * 1000) + 100;
                const redundancy = Math.floor(Math.random() * 100);
                
                this.addActivity(`üíæ Visual state backup: ${backupSize}MB (${redundancy}% redundancy)`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üíæ Visual backup: ${backupSize}MB, ${redundancy}% redundancy`);
                
                return `Visual state backup: ${backupSize}MB (${redundancy}% redundancy)`;
            },

            restoreVisualState() {
                console.log("üîÑ Matrix Rain: Restoring visual state...");
                
                const restoreTime = Math.floor(Math.random() * 3000) + 1000;
                
                this.addActivity(`üîÑ Visual state restore initiated (${restoreTime}ms)`, true);
                this.addAuditEntry(`[üåä Matrix Rain] üîÑ Visual restore initiated: ${restoreTime}ms`);
                
                setTimeout(() => {
                    this.addActivity('üîÑ Visual state restore completed', true);
                    this.addAuditEntry('[üåä Matrix Rain] üîÑ Visual restore completed');
                }, restoreTime);
                
                return `Visual state restore initiated (${restoreTime}ms)`;
            },

            emergencyStop() {
                console.log("üö® Matrix Rain: Emergency stop initiated...");
                
                this.addActivity('üö® EMERGENCY STOP INITIATED!', true);
                this.addAuditEntry('[üåä Matrix Rain] üö® Emergency stop protocol executed');
                
                setTimeout(() => {
                    alert('Emergency stop completed. All visual patterns safely halted.');
                }, 2000);
                
                return 'Emergency stop initiated';
            },

            // === UTILITY FUNCTIONS ===
            addActivity(message, isRecent = false) {
                const activityFeed = document.querySelector('.activity-feed');
                if (!activityFeed) {
                    console.log(`üåä Matrix Rain: ${message} (activity feed not found)`);
                    return;
                }
                const activityItem = document.createElement('div');
                activityItem.className = 'activity-item';
                activityItem.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
                activityFeed.insertBefore(activityItem, activityFeed.firstChild);
                if (activityFeed.children.length > 20) {
                    activityFeed.removeChild(activityFeed.lastChild);
                }
                if (isRecent) {
                    setTimeout(() => {
                        activityItem.classList.remove('recent');
                    }, 5000);
                }
            },

            addAuditEntry(message) {
                const auditCanvas = document.querySelector('.audit-canvas');
                if (!auditCanvas) {
                    console.log(`üåä Matrix Rain: ${message} (audit canvas not found)`);
                    return;
                }
                const auditEntry = document.createElement('div');
                auditEntry.className = 'audit-entry';
                auditEntry.textContent = message;
                auditCanvas.insertBefore(auditEntry, auditCanvas.firstChild);
                if (auditCanvas.children.length > 15) {
                    auditCanvas.removeChild(auditCanvas.lastChild);
                }
            },

            // === INITIALIZATION ===
            init() {
                this.addActivity('üåä Matrix Rain Advanced Visual Control Unit initialized', true);
                this.addAuditEntry('[üåä Matrix Rain] üåä Advanced Visual Control Unit initialized');
                console.log("üåä Matrix Rain Advanced Visual Control Unit initialized");
            }
        };

        // === GLOBAL FUNCTIONS FOR BUTTON INTERACTIONS ===
        function setRainPattern(pattern, buttonElement) { MatrixRainEngine.setRainPattern(pattern, buttonElement); }
        function updateRainSpeed() { MatrixRainEngine.updateRainSpeed(); }
        function updateRainIntensity() { MatrixRainEngine.updateRainIntensity(); }
        function updateRainDensity() { MatrixRainEngine.updateRainDensity(); }
        function updateRainColors() { MatrixRainEngine.updateRainColors(); }
        function updateFontSize() { MatrixRainEngine.updateFontSize(); }
        function updateCharacterSet() { MatrixRainEngine.updateCharacterSet(); }
        function updateRainDirection() { MatrixRainEngine.updateRainDirection(); }
        function setSpectrumColor(color, colorElement) { MatrixRainEngine.setSpectrumColor(color, colorElement); }
        function activatePatternAnalysis() { MatrixRainEngine.activatePatternAnalysis(); }
        function resurrectVisualData() { MatrixRainEngine.resurrectVisualData(); }
        function harmonizePatterns() { MatrixRainEngine.harmonizePatterns(); }
        function createEchoChamber() { MatrixRainEngine.createEchoChamber(); }
        function interpretSymbols() { MatrixRainEngine.interpretSymbols(); }
        function optimizeFlow() { MatrixRainEngine.optimizeFlow(); }
        function backupVisualState() { MatrixRainEngine.backupVisualState(); }
        function restoreVisualState() { MatrixRainEngine.restoreVisualState(); }
        function emergencyStop() { MatrixRainEngine.emergencyStop(); }

        function closeMatrixModal() {
            const modal = document.querySelector('.matrix-modal');
            modal.style.display = 'none';
        }

        function toggleMatrixModal() {
            const modal = document.querySelector('.matrix-modal');
            const minimizeBtn = document.getElementById('minimizeBtn');

            if (modal.classList.contains('minimized')) {
                modal.classList.remove('minimized');
                minimizeBtn.textContent = '‚àí';
                minimizeBtn.title = 'Minimize utilities to see matrix rain';
            } else {
                modal.classList.add('minimized');
                minimizeBtn.textContent = 'M +';
                minimizeBtn.title = 'Press M or click to maximize';
            }
        }

        // === MATRIX RAIN ANIMATION ENGINE ===
        let matrixCanvas, matrixCtx, matrixDrops, matrixInterval;
        
        function initMatrixRain() {
            console.log("üåä Matrix Rain: Initializing animation...");
            matrixCanvas = document.getElementById('matrixRainCanvas');
            if (!matrixCanvas) {
                console.error("üåä Matrix Rain: Canvas element not found!");
                return;
            }
            matrixCtx = matrixCanvas.getContext('2d');
            if (!matrixCtx) {
                console.error("üåä Matrix Rain: Could not get canvas context!");
                return;
            }
            console.log("üåä Matrix Rain: Canvas initialized successfully");
            
            // Ensure canvas is visible
            matrixCanvas.style.display = 'block';
            matrixCanvas.style.opacity = '0.8';
            console.log("üåä Matrix Rain: Canvas visibility set to:", matrixCanvas.style.display, "opacity:", matrixCanvas.style.opacity);
            
            // Set canvas size
            function resizeCanvas() {
                matrixCanvas.width = window.innerWidth;
                matrixCanvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize drops
            const fontSize = MatrixRainEngine.rainConfig.fontSize;
            const columns = Math.floor(matrixCanvas.width / fontSize);
            matrixDrops = [];
            window.dropSpeeds = []; // Per-column speed variation
            window.horizontalYPositions = []; // Y positions for horizontal rain

            for (let i = 0; i < columns; i++) {
                // Highly randomized starting positions - spread across entire visible + off-screen area
                matrixDrops[i] = (Math.random() * matrixCanvas.height / fontSize) - (Math.random() * 50);
                // Random speed variation (0.7 to 1.3x normal speed)
                window.dropSpeeds[i] = 0.7 + Math.random() * 0.6;
                // Random Y position for horizontal rain (spread across screen height)
                window.horizontalYPositions[i] = Math.random() * (matrixCanvas.height / fontSize);
            }
            
            console.log(`üåä Matrix Rain: Initialized ${columns} columns with font size ${fontSize}`);
            
            // Start animation
            startMatrixAnimation();
        }
        
        function startMatrixAnimation() {
            if (matrixInterval) {
                clearInterval(matrixInterval);
            }
            
            const speed = MatrixRainEngine.rainConfig.speed;
            console.log(`üåä Matrix Rain: Starting animation with speed ${speed}ms`);
            matrixInterval = setInterval(drawMatrixRain, speed);
            console.log(`üåä Matrix Rain: Animation interval set: ${matrixInterval}`);
        }
        
        // Helper function to get random character
        function getNextCharacter(characters, columnIndex, isUserColumn) {
            return characters[Math.floor(Math.random() * characters.length)];
        }

        function drawMatrixRain() {
            const config = MatrixRainEngine.rainConfig;
            const fontSize = config.fontSize;
            const opacity = 1.0; // Always full opacity

            // Debug: Log first few calls
            if (!window.drawCount) window.drawCount = 0;
            window.drawCount++;
            if (window.drawCount <= 5) {
                console.log(`üåä Matrix Rain: Draw call #${window.drawCount}, pattern: ${config.pattern}, opacity: ${opacity}`);
            }
            

            // === AUTO-CONTRAST BACKGROUND ===
            // Calculate complementary color based on current character colors
            function hexToHSL_bg(hex) {
                hex = hex.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
            }

            // Get average hue from primary and secondary colors
            let avgHue = 0;
            let primaryHSL, secondaryHSL;

            if (config.primaryColor) {
                if (config.primaryColor.includes('#')) {
                    primaryHSL = hexToHSL_bg(config.primaryColor);
                } else if (config.primaryColor.includes('hsl')) {
                    const match = config.primaryColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                    if (match) primaryHSL = { h: parseInt(match[1]), s: parseInt(match[2]), l: parseInt(match[3]) };
                }
            }

            if (config.secondaryColor) {
                if (config.secondaryColor.includes('#')) {
                    secondaryHSL = hexToHSL_bg(config.secondaryColor);
                } else if (config.secondaryColor.includes('hsl')) {
                    const match = config.secondaryColor.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                    if (match) secondaryHSL = { h: parseInt(match[1]), s: parseInt(match[2]), l: parseInt(match[3]) };
                }
            }

            // Calculate average hue
            if (primaryHSL && secondaryHSL) {
                avgHue = (primaryHSL.h + secondaryHSL.h) / 2;
            } else if (primaryHSL) {
                avgHue = primaryHSL.h;
            } else {
                avgHue = 120; // Default green
            }

            // Complementary color (opposite on color wheel)
            const complementHue = (avgHue + 180) % 360;

            // Clear canvas with auto-contrast background (dark complementary color)
            matrixCtx.fillStyle = `hsla(${complementHue}, 80%, 8%, 0.12)`;
            matrixCtx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            
            // Set font
            matrixCtx.font = `${fontSize}px monospace`;
            
            // Get character set
            let characters = config.characterSet;
            if (characters === 'matrix') {
                characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}';
            } else if (characters === 'binary') {
                characters = '01';
            } else if (characters === 'hex') {
                characters = '0123456789ABCDEF';
            } else if (characters === 'symbols') {
                characters = '@#$%^&*()_+-=[]{}|;:,.<>?';
            } else if (characters === 'katakana') {
                characters = '„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„Éé„Éè„Éí„Éï„Éò„Éõ„Éû„Éü„É†„É°„É¢„É§„É¶„É®„É©„É™„É´„É¨„É≠„ÉØ„É≤„É≥„Ç¨„ÇÆ„Ç∞„Ç≤„Ç¥„Ç∂„Ç∏„Ç∫„Çº„Çæ„ÉÄ„ÉÇ„ÉÖ„Éá„Éâ„Éê„Éì„Éñ„Éô„Éú„Éë„Éî„Éó„Éö„Éù';
            }

            // Draw rain based on DIRECTION first, then pattern
            const direction = config.direction;

            if (direction === 'toward') {
                // 3D toward camera mode - uses special positioning with any pattern
                draw3DTowardCamera(characters, fontSize, opacity, config.pattern);
            } else {
                // Traditional 2D directional rain
                if (config.pattern === 'particles') {
                    drawParticleField(characters, fontSize, opacity);
                } else if (config.pattern === 'rainbow') {
                    drawRainbowRain(characters, fontSize, opacity);
                } else if (config.pattern === 'pentad') {
                    drawPentadRain(characters, fontSize, opacity);
                } else if (config.pattern === 'chaos') {
                    drawChaosRain(characters, fontSize, opacity);
                } else if (config.pattern === 'harmonic') {
                    drawHarmonicRain(characters, fontSize, opacity);
                } else {
                    drawClassicRain(characters, fontSize, opacity);
                }
            }
        }
        
        // Track animation state for all patterns
        if (!window.geometricState) {
            window.geometricState = {
                time: 0,
                rotation: 0,
                pulsePhase: 0,
                selectedPattern: 0
            };
        }
        
        // Particle system state
        if (!window.particles) {
            window.particles = [];
        }
        
        function drawClassicRain(characters, fontSize, opacity) {
            const config = MatrixRainEngine.rainConfig;
            const direction = config.direction || 'down';
            
            // Debug: Log drawing info for first few frames
            if (window.drawCount <= 3) {
                console.log(`üåä Matrix Rain: Direction ${direction}, color: ${config.primaryColor}`);
            }
            
            if (direction === 'left' || direction === 'right') {
                // HORIZONTAL rain (left/right) - USE ALL DROPS
                const columns = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < columns; i++) {
                    // Check if this is a user message column FIRST
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip columns used ONLY by Ollama (don't skip user columns even if Ollama uses them)
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const y = (window.horizontalYPositions && window.horizontalYPositions[i] ? window.horizontalYPositions[i] : Math.random() * (matrixCanvas.height / fontSize)) * fontSize;
                    const x = matrixDrops[i] * fontSize;

                    matrixCtx.fillStyle = config.primaryColor;
                    matrixCtx.globalAlpha = opacity;
                    matrixCtx.fillText(char, x, y);

                    // Update horizontal position
                    const dropSpeed = window.dropSpeeds && window.dropSpeeds[i] ? window.dropSpeeds[i] : 1;
                    matrixDrops[i] += dropSpeed * (direction === 'left' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxCols = matrixCanvas.width / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxCols + 10;
                    while (matrixDrops[i] > maxCols) matrixDrops[i] -= maxCols + 10;
                }
            } else if (direction === 'diagonal') {
                // DIAGONAL rain
                const streams = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < streams; i++) {
                    // Check if this is a user message column FIRST
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip streams used ONLY by Ollama (don't skip user columns even if Ollama uses them)
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const progress = matrixDrops[i];
                    const x = i * fontSize + progress * fontSize * 0.5;
                    const y = progress * fontSize;

                    if (x < matrixCanvas.width && y < matrixCanvas.height) {
                        matrixCtx.fillStyle = config.primaryColor;
                        matrixCtx.globalAlpha = opacity;
                        matrixCtx.fillText(char, x, y);
                    }
                    
                    const dropSpeed = window.dropSpeeds && window.dropSpeeds[i] ? window.dropSpeeds[i] : 1;
                    matrixDrops[i] += dropSpeed * reverseFlowMultiplier;
                    
                    // Simple wrap around - bulletproof
                    const maxDiag = matrixCanvas.height / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxDiag + 10;
                    while (matrixDrops[i] > maxDiag) matrixDrops[i] -= maxDiag + 10;
                    }
                } else {
                // VERTICAL rain (up/down)
                const columns = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < columns; i++) {
                    // Check if this is a user message column FIRST
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip columns used ONLY by Ollama (don't skip user columns even if Ollama uses them)
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const x = i * fontSize;
                    const y = matrixDrops[i] * fontSize;

                    matrixCtx.fillStyle = config.primaryColor;
                    matrixCtx.globalAlpha = opacity;
                    matrixCtx.fillText(char, x, y);
                    
                    // Update vertical position
                    const dropSpeed = window.dropSpeeds && window.dropSpeeds[i] ? window.dropSpeeds[i] : 1;
                    matrixDrops[i] += dropSpeed * (direction === 'up' ? -1 : 1) * reverseFlowMultiplier;
                    
                    // Simple wrap around - bulletproof
                    const maxRows = matrixCanvas.height / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxRows + 10;
                    while (matrixDrops[i] > maxRows) matrixDrops[i] -= maxRows + 10;
                }
            }
        }
        
        function drawRainbowRain(characters, fontSize, opacity) {
            const config = MatrixRainEngine.rainConfig;
            const direction = config.direction || 'down';
            const colors = ['#ff0000', '#ff8000', '#ffff00', '#00ff00', '#0080ff', '#8000ff', '#ff0080'];

            if (direction === 'left' || direction === 'right') {
                const columns = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < columns; i++) {
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip columns used ONLY by Ollama (don't skip user columns even if Ollama uses them)
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const y = (window.horizontalYPositions && window.horizontalYPositions[i] ? window.horizontalYPositions[i] : Math.random() * (matrixCanvas.height / fontSize)) * fontSize;
                    const x = matrixDrops[i] * fontSize;
                    const colorIndex = Math.floor((i + Date.now() / 100) % colors.length);

                    matrixCtx.fillStyle = colors[colorIndex];
                    matrixCtx.globalAlpha = opacity;
                    matrixCtx.fillText(char, x, y);

                    matrixDrops[i] += (direction === 'left' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxCols = matrixCanvas.width / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxCols + 10;
                    while (matrixDrops[i] > maxCols) matrixDrops[i] -= maxCols + 10;
                }
            } else {
                const columns = Math.floor(matrixCanvas.width / fontSize);
            for (let i = 0; i < columns; i++) {
                const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                // Skip columns used ONLY by Ollama (don't skip user columns even if Ollama uses them)
                if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                    continue;
                }

                const char = getNextCharacter(characters, i, isUserColumn);
                const x = i * fontSize;
                const y = matrixDrops[i] * fontSize;
                const colorIndex = Math.floor((i + Date.now() / 100) % colors.length);

                    matrixCtx.fillStyle = colors[colorIndex];
                matrixCtx.globalAlpha = opacity;
                matrixCtx.fillText(char, x, y);

                    matrixDrops[i] += (direction === 'up' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxRows = matrixCanvas.height / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxRows + 10;
                    while (matrixDrops[i] > maxRows) matrixDrops[i] -= maxRows + 10;
                }
            }
        }
        
        function drawPentadRain(characters, fontSize, opacity) {
            const config = MatrixRainEngine.rainConfig;
            const direction = config.direction || 'down';
            const pentadColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];

            if (direction === 'left' || direction === 'right') {
                const columns = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < columns; i++) {
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip columns used ONLY by Ollama
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const y = (window.horizontalYPositions && window.horizontalYPositions[i] ? window.horizontalYPositions[i] : Math.random() * (matrixCanvas.height / fontSize)) * fontSize;
                    const x = matrixDrops[i] * fontSize;
                    const color = pentadColors[i % 5];

                    matrixCtx.fillStyle = color;
                    matrixCtx.globalAlpha = opacity;
                    matrixCtx.fillText(char, x, y);

                    matrixDrops[i] += (0.5 + Math.random() * 0.5) * (direction === 'left' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxCols = matrixCanvas.width / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxCols + 10;
                    while (matrixDrops[i] > maxCols) matrixDrops[i] -= maxCols + 10;
                }
            } else {
                const columns = Math.floor(matrixCanvas.width / fontSize);
            for (let i = 0; i < columns; i++) {
                const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                // Skip columns used ONLY by Ollama
                if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                    continue;
                }

                const char = getNextCharacter(characters, i, isUserColumn);
                const x = i * fontSize;
                const y = matrixDrops[i] * fontSize;
                    const color = pentadColors[i % 5];

                matrixCtx.fillStyle = color;
                matrixCtx.globalAlpha = opacity;
                matrixCtx.fillText(char, x, y);

                    matrixDrops[i] += (0.5 + Math.random() * 0.5) * (direction === 'up' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxRows = matrixCanvas.height / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxRows + 10;
                    while (matrixDrops[i] > maxRows) matrixDrops[i] -= maxRows + 10;
                }
            }
        }
        
        function drawChaosRain(characters, fontSize, opacity) {
            const config = MatrixRainEngine.rainConfig;
            const direction = config.direction || 'down';

            if (direction === 'left' || direction === 'right') {
                const columns = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < columns; i++) {
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip columns used ONLY by Ollama
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const y = ((window.horizontalYPositions && window.horizontalYPositions[i] ? window.horizontalYPositions[i] : Math.random() * (matrixCanvas.height / fontSize)) * fontSize) + (Math.random() - 0.5) * 10;
                    const x = matrixDrops[i] * fontSize;
                    const hue = (Date.now() + i * 50) % 360;

                    matrixCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    matrixCtx.globalAlpha = opacity;
                    matrixCtx.fillText(char, x, y);

                    matrixDrops[i] += (0.2 + Math.random() * 1.5) * (direction === 'left' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxCols = matrixCanvas.width / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxCols + 10;
                    while (matrixDrops[i] > maxCols) matrixDrops[i] -= maxCols + 10;
                }
            } else {
                const columns = Math.floor(matrixCanvas.width / fontSize);
            for (let i = 0; i < columns; i++) {
                const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                // Skip columns used ONLY by Ollama
                if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                    continue;
                }

                const char = getNextCharacter(characters, i, isUserColumn);
                    const x = i * fontSize + (Math.random() - 0.5) * 10;
                const y = matrixDrops[i] * fontSize;
                const hue = (Date.now() + i * 50) % 360;

                    matrixCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                matrixCtx.globalAlpha = opacity;
                matrixCtx.fillText(char, x, y);

                    matrixDrops[i] += (0.2 + Math.random() * 1.5) * (direction === 'up' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxRows = matrixCanvas.height / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxRows + 10;
                    while (matrixDrops[i] > maxRows) matrixDrops[i] -= maxRows + 10;
                }
            }
        }
        
        function drawHarmonicRain(characters, fontSize, opacity) {
            const config = MatrixRainEngine.rainConfig;
            const direction = config.direction || 'down';

            if (direction === 'left' || direction === 'right') {
                const columns = Math.floor(matrixCanvas.width / fontSize);
                for (let i = 0; i < columns; i++) {
                    const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                    // Skip columns used ONLY by Ollama
                    if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                        continue;
                    }

                    const char = getNextCharacter(characters, i, isUserColumn);
                    const y = (window.horizontalYPositions && window.horizontalYPositions[i] ? window.horizontalYPositions[i] : Math.random() * (matrixCanvas.height / fontSize)) * fontSize;
                    const x = matrixDrops[i] * fontSize;
                    const wave = Math.sin(Date.now() / 1000 + i * 0.1) * 5;
                    const harmonicX = x + wave;
                    const hue = 120 + Math.sin(Date.now() / 2000 + i * 0.05) * 60;

                    matrixCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    matrixCtx.globalAlpha = opacity;
                    matrixCtx.fillText(char, harmonicX, y);

                    matrixDrops[i] += 0.8 * (direction === 'left' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxCols = matrixCanvas.width / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxCols + 10;
                    while (matrixDrops[i] > maxCols) matrixDrops[i] -= maxCols + 10;
                }
            } else {
                const columns = Math.floor(matrixCanvas.width / fontSize);
            for (let i = 0; i < columns; i++) {
                const isUserColumn = window.userMessageColumns && window.userMessageColumns.has(i);

                // Skip columns used ONLY by Ollama
                if (!isUserColumn && window.ollamaMessageColumns && window.ollamaMessageColumns.has(i)) {
                    continue;
                }

                const char = getNextCharacter(characters, i, isUserColumn);
                const x = i * fontSize;
                const y = matrixDrops[i] * fontSize;
                const wave = Math.sin(Date.now() / 1000 + i * 0.1) * 5;
                const harmonicY = y + wave;
                const hue = 120 + Math.sin(Date.now() / 2000 + i * 0.05) * 60;

                    matrixCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                matrixCtx.globalAlpha = opacity;
                matrixCtx.fillText(char, x, harmonicY);

                    matrixDrops[i] += 0.8 * (direction === 'up' ? -1 : 1) * reverseFlowMultiplier;

                    // Simple wrap around - bulletproof
                    const maxRows = matrixCanvas.height / fontSize;
                    while (matrixDrops[i] < 0) matrixDrops[i] += maxRows + 10;
                    while (matrixDrops[i] > maxRows) matrixDrops[i] -= maxRows + 10;
                }
            }
        }
        // === PARTICLE FIELD ===
        function drawParticleField(characters, fontSize, opacity) {
            const config = MatrixRainEngine.rainConfig;
            const numParticles = Math.floor(config.intensity * 3);
            
            if (window.particles.length === 0) {
                for (let i = 0; i < numParticles; i++) {
                    window.particles.push({
                        x: Math.random() * matrixCanvas.width,
                        y: Math.random() * matrixCanvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        char: getNextCharacter(characters, i, false),
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }
            
            const speedFactor = config.speed / 50;
            const centerX = matrixCanvas.width / 2;
            const centerY = matrixCanvas.height / 2;
            
            for (let i = 0; i < Math.min(window.particles.length, numParticles); i++) {
                const p = window.particles[i];
                
                const dx = centerX - p.x;
                const dy = centerY - p.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const force = (dist / 500) * 0.5;
                
                p.vx += (dy / dist) * force * speedFactor * reverseFlowMultiplier;
                p.vy += (-dx / dist) * force * speedFactor * reverseFlowMultiplier;
                
                p.x += p.vx * reverseFlowMultiplier;
                p.y += p.vy * reverseFlowMultiplier;
                
                p.vx *= 0.99;
                p.vy *= 0.99;
                
                if (p.x < 0) p.x = matrixCanvas.width;
                if (p.x > matrixCanvas.width) p.x = 0;
                if (p.y < 0) p.y = matrixCanvas.height;
                if (p.y > matrixCanvas.height) p.y = 0;
                
                p.phase += 0.05 * reverseFlowMultiplier;
                const pulse = Math.sin(p.phase) * 0.3 + 0.7;
                const size = fontSize * pulse;
                const hue = (i * 10 + window.geometricState.time * 20) % 360;
                
                matrixCtx.font = `${size}px monospace`;
                matrixCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                matrixCtx.globalAlpha = opacity;
                matrixCtx.fillText(p.char, p.x, p.y);
            }
            
            window.geometricState.time += 0.02 * reverseFlowMultiplier;
        }

        // === 3D TUNNEL EFFECT (Hackers Gibson Scene) ===
        // Initialize tunnel characters
        if (!window.tunnelChars) {
            window.tunnelChars = [];
        }

        function draw3DTowardCamera(characters, fontSize, opacity, pattern) {
            const config = MatrixRainEngine.rainConfig;
            const speedFactor = config.speed / 50;

            const numChars = Math.floor(config.intensity * 1.5); // Reduced density - less busy

            // Initialize tunnel characters if needed (or adjust count)
            if (window.tunnelChars.length === 0 || window.tunnelChars.length !== numChars) {
                window.tunnelChars = []; // Clear and reinitialize
                for (let i = 0; i < numChars; i++) {
                    // Random starting position across ENTIRE screen area
                    // Use normalized coordinates (0-1) that work at any depth
                    const startX = Math.random(); // 0-1 across width
                    const startY = Math.random(); // 0-1 across height

                    window.tunnelChars.push({
                        char: getNextCharacter(characters, i, false),
                        zDepth: Math.random(), // 0 = far away, 1 = at camera
                        startX: startX, // Normalized X position (0-1)
                        startY: startY, // Normalized Y position (0-1)
                        speedMultiplier: 0.5 + Math.random() * 1.5 // Each character moves at different speed
                    });
                }
            }

            // Sort by Z-depth so far ones draw first (painter's algorithm)
            window.tunnelChars.sort((a, b) => a.zDepth - b.zDepth);

            // Draw each character
            for (let i = 0; i < window.tunnelChars.length; i++) {
                const tc = window.tunnelChars[i];

                // Move toward camera with individual speed variation
                tc.zDepth += speedFactor * 0.02 * reverseFlowMultiplier * tc.speedMultiplier;

                // Cycle character randomly (creates animated ripple effect like classic rain)
                if (!tc.cycleCounter) tc.cycleCounter = 0;
                tc.cycleCounter++;
                if (tc.cycleCounter > 3) { // Change character every 3-4 frames
                    tc.char = getNextCharacter(characters, i, false);
                    tc.cycleCounter = 0;
                }

                // Reset when reaching camera (or going backward past vanishing point)
                if (tc.zDepth > 1) {
                    tc.zDepth = 0;
                    tc.char = getNextCharacter(characters, i, false);
                    tc.speedMultiplier = 0.5 + Math.random() * 1.5; // New random speed
                    tc.startX = Math.random(); // New random position
                    tc.startY = Math.random();
                } else if (tc.zDepth < 0) {
                    tc.zDepth = 1;
                    tc.char = getNextCharacter(characters, i, false);
                    tc.speedMultiplier = 0.5 + Math.random() * 1.5; // New random speed
                    tc.startX = Math.random(); // New random position
                    tc.startY = Math.random();
                }

                // Calculate position - characters grow straight at you from their position
                // Parallax effect: things further away (low zDepth) appear closer to center
                const centerX = matrixCanvas.width / 2;
                const centerY = matrixCanvas.height / 2;

                // Start position in pixels
                const baseX = tc.startX * matrixCanvas.width;
                const baseY = tc.startY * matrixCanvas.height;

                // Parallax: far things converge toward center, near things spread out
                // At zDepth=0 (far): position is 70% toward center
                // At zDepth=1 (near): position is at full baseX/baseY (or beyond)
                const parallaxFactor = 0.3 + tc.zDepth * 1.2; // 0.3 to 1.5
                const x = centerX + (baseX - centerX) * parallaxFactor;
                const y = centerY + (baseY - centerY) * parallaxFactor;

                // AGGRESSIVE SCALING - creates that "rushing toward camera" effect
                // Characters at vanishing point are tiny, at camera are HUGE
                const scale = 0.1 + (tc.zDepth * 3.5); // 0.1x ‚Üí 3.6x (aggressive!)
                const charSize = fontSize * scale;

                // Opacity: fade in as approaching camera
                const charOpacity = Math.min(opacity, tc.zDepth * 0.9 + 0.1);

                // === DANCING COLORS BETWEEN PRIMARY AND SECONDARY ===
                const time = window.geometricState.time * 0.001;

                // Helper function to convert hex to HSL
                function hexToHSL(hex) {
                    // Remove # if present
                    hex = hex.replace('#', '');

                    // Parse RGB
                    const r = parseInt(hex.substr(0, 2), 16) / 255;
                    const g = parseInt(hex.substr(2, 2), 16) / 255;
                    const b = parseInt(hex.substr(4, 2), 16) / 255;

                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;

                    if (max === min) {
                        h = s = 0; // achromatic
                    } else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                        switch (max) {
                            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                            case g: h = ((b - r) / d + 2) / 6; break;
                            case b: h = ((r - g) / d + 4) / 6; break;
                        }
                    }

                    return {
                        h: Math.round(h * 360),
                        s: Math.round(s * 100),
                        l: Math.round(l * 100)
                    };
                }

                // Parse primary color (supports both hex and hsl)
                let primaryHue = 120, primarySat = 100;
                if (config.primaryColor) {
                    if (config.primaryColor.includes('hsl')) {
                        const match = config.primaryColor.match(/hsl\((\d+),\s*(\d+)%/);
                        if (match) {
                            primaryHue = parseInt(match[1]);
                            primarySat = parseInt(match[2]);
                        }
                    } else if (config.primaryColor.includes('#')) {
                        const hsl = hexToHSL(config.primaryColor);
                        primaryHue = hsl.h;
                        primarySat = hsl.s;
                    }
                }

                // Parse secondary color (supports both hex and hsl)
                let secondaryHue = 180, secondarySat = 100;
                if (config.secondaryColor) {
                    if (config.secondaryColor.includes('hsl')) {
                        const match = config.secondaryColor.match(/hsl\((\d+),\s*(\d+)%/);
                        if (match) {
                            secondaryHue = parseInt(match[1]);
                            secondarySat = parseInt(match[2]);
                        }
                    } else if (config.secondaryColor.includes('#')) {
                        const hsl = hexToHSL(config.secondaryColor);
                        secondaryHue = hsl.h;
                        secondarySat = hsl.s;
                    }
                }

                // === WAVE EFFECTS ===
                // Color waves moving through tunnel depth (oscillates between 0 and 1)
                const depthWave = (Math.sin(tc.zDepth * 8 - time * 2) + 1) / 2;

                // Spatial color wave based on position
                const spatialWave = (Math.sin(tc.startX * 10 + tc.startY * 8 + tc.zDepth * 5 + time * 1.5) + 1) / 2;

                // Combine waves
                const colorMix = (depthWave * 0.6 + spatialWave * 0.4);

                // Lerp between primary and secondary colors
                const finalHue = primaryHue + (secondaryHue - primaryHue) * colorMix;
                const finalSat = primarySat + (secondarySat - primarySat) * colorMix;

                // Brightness modulation
                const brightnessWave = Math.sin(tc.zDepth * 15 - time * 3);
                const lightness = 50 + brightnessWave * 15;

                // Draw the character - oscillating between two colors
                matrixCtx.font = `${charSize}px monospace`;
                matrixCtx.fillStyle = `hsl(${finalHue}, ${finalSat}%, ${lightness}%)`;
                matrixCtx.globalAlpha = charOpacity;

                // No motion blur - clean crisp characters
                matrixCtx.shadowBlur = 0;

                matrixCtx.fillText(tc.char, x, y);
            }

            // Reset shadow
            matrixCtx.shadowBlur = 0;
        }

        // === CONTROL FUNCTIONS ===
        function updateRainConfig() {
            const config = MatrixRainEngine.rainConfig;
            console.log('Matrix Rain Config Updated:', config);
            MatrixRainEngine.logActivity('Configuration updated', 'info');
            
            // Update animation with new settings
            if (matrixInterval) {
                startMatrixAnimation();
            }
        }
        
        function toggleMatrixRain() {
            const canvas = document.getElementById('matrixRainCanvas');
            if (canvas.style.display === 'none') {
                canvas.style.display = 'block';
                startMatrixAnimation();
                MatrixRainEngine.logActivity('Matrix rain activated', 'success');
            } else {
                canvas.style.display = 'none';
                if (matrixInterval) {
                    clearInterval(matrixInterval);
                }
                MatrixRainEngine.logActivity('Matrix rain deactivated', 'warning');
            }
        }
        
        function emergencyStop() {
            const canvas = document.getElementById('matrixRainCanvas');
            canvas.style.display = 'none';
            if (matrixInterval) {
                clearInterval(matrixInterval);
            }
            MatrixRainEngine.logActivity('EMERGENCY STOP: Matrix rain terminated', 'error');
        }
        
        function setRainPattern(pattern, buttonElement) {
            MatrixRainEngine.rainConfig.pattern = pattern;
            updateRainConfig();

            // Update active button
            document.querySelectorAll('.pattern-btn').forEach(btn => btn.classList.remove('active'));
            if (buttonElement) {
                buttonElement.classList.add('active');
            }
        }
        
        function updateRainSpeed() {
            const speed = document.getElementById('rainSpeed').value;
            MatrixRainEngine.rainConfig.speed = 101 - speed; // Invert for intuitive control
            updateRainConfig();
        }
        
        function updateRainIntensity() {
            const intensity = document.getElementById('rainIntensity').value;
            MatrixRainEngine.rainConfig.intensity = intensity;
            updateRainConfig();
        }
        
        function updateRainDensity() {
            const density = document.getElementById('rainDensity').value;
            MatrixRainEngine.rainConfig.density = density;
            updateRainConfig();
        }
        
        function updateRainColors() {
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            MatrixRainEngine.rainConfig.primaryColor = primary;
            MatrixRainEngine.rainConfig.secondaryColor = secondary;
            updateRainConfig();
        }

        function updateFontSize() {
            const fontSize = document.getElementById('fontSize').value;
            MatrixRainEngine.rainConfig.fontSize = parseInt(fontSize);
            updateRainConfig();
        }
        
        function updateCharacterSet() {
            const characterSet = document.getElementById('characterSet').value;
            const customInput = document.getElementById('customCharacters');

            // Show/hide custom input based on selection
            if (characterSet === 'custom') {
                customInput.style.display = 'block';
                // Use custom characters if provided, otherwise use default
                const customChars = customInput.value.trim();
                MatrixRainEngine.rainConfig.characterSet = customChars.length > 0 ? customChars : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            } else {
                customInput.style.display = 'none';
                MatrixRainEngine.rainConfig.characterSet = characterSet;
            }

            updateRainConfig();
        }
        
        function updateRainDirection() {
            const direction = document.getElementById('rainDirection').value;
            const oldDirection = MatrixRainEngine.rainConfig.direction;
            MatrixRainEngine.rainConfig.direction = direction;

            // Reinitialize drop positions when switching to/from horizontal
            if (matrixCanvas && matrixDrops) {
                const fontSize = MatrixRainEngine.rainConfig.fontSize;
                const wasHorizontal = (oldDirection === 'left' || oldDirection === 'right');
                const isHorizontal = (direction === 'left' || direction === 'right');

                if (wasHorizontal !== isHorizontal) {
                    // Switching orientation - reinitialize all drops
                    const columns = Math.floor(matrixCanvas.width / fontSize);
                    for (let i = 0; i < columns; i++) {
                        if (isHorizontal) {
                            // Going horizontal: randomize X positions across full width
                            matrixDrops[i] = Math.random() * (matrixCanvas.width / fontSize);
                        } else {
                            // Going vertical: randomize Y positions across full height
                            matrixDrops[i] = Math.random() * (matrixCanvas.height / fontSize);
                        }
                    }
                }
            }

            updateRainConfig();
        }
        
        function setSpectrumColor(color, colorElement) {
            document.querySelectorAll('.spectrum-color').forEach(btn => btn.classList.remove('active'));
            if (colorElement) {
                colorElement.classList.add('active');
            }
            MatrixRainEngine.rainConfig.primaryColor = color;
            updateRainConfig();
        }

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', function() {
            console.log("üåä Matrix Rain: DOM loaded, initializing...");
            MatrixRainEngine.init();

            // Set initial minimize button state (starts minimized)
            const minimizeBtn = document.getElementById('minimizeBtn');
            minimizeBtn.textContent = 'M +';
            minimizeBtn.title = 'Press M or click to maximize';

            // Wait a bit for the engine to initialize, then start the rain
            setTimeout(() => {
                initMatrixRain();
                console.log("üåä Matrix Rain: Animation engine initialized");
            }, 100);
            
            // Add keyboard shortcut: Press 'M' to toggle settings modal
            document.addEventListener('keydown', function(e) {
                if (e.key === 'm' || e.key === 'M') {
                    const modal = document.querySelector('.matrix-modal');
                    if (modal.style.display === 'none') {
                        modal.style.display = 'flex';
                        MatrixRainEngine.logActivity('‚å®Ô∏è Settings opened (M key)', 'info');
                    } else {
                        modal.style.display = 'none';
                        MatrixRainEngine.logActivity('‚å®Ô∏è Settings closed (M key)', 'info');
                    }
                }
            });
        });
        
        // === CHAOS RANDOMIZER ===
        function activateChaosRandomizer() {
            console.log("üåÄ CHAOS RANDOMIZER ACTIVATED!");
            MatrixRainEngine.logActivity("üåÄ CHAOS RANDOMIZER: Initiating complete system chaos!", 'success');
            
            // Randomize all settings with all available patterns!
            const patterns = ['classic', 'rainbow', 'pentad', 'chaos', 'harmonic', 'particles'];
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8000', '#8000ff'];
            const characterSets = ['matrix', 'binary', 'hex', 'symbols', 'katakana'];
            const directions = ['down', 'up', 'left', 'right', 'diagonal', 'toward'];
            
            // Apply random settings
            MatrixRainEngine.rainConfig.pattern = patterns[Math.floor(Math.random() * patterns.length)];
            MatrixRainEngine.rainConfig.primaryColor = colors[Math.floor(Math.random() * colors.length)];
            MatrixRainEngine.rainConfig.secondaryColor = colors[Math.floor(Math.random() * colors.length)];
            MatrixRainEngine.rainConfig.speed = Math.floor(Math.random() * 50) + 10;
            MatrixRainEngine.rainConfig.characterSet = characterSets[Math.floor(Math.random() * characterSets.length)];
            MatrixRainEngine.rainConfig.direction = directions[Math.floor(Math.random() * directions.length)];

            // Update UI controls
            document.getElementById('rainSpeed').value = 101 - MatrixRainEngine.rainConfig.speed;
            document.getElementById('primaryColor').value = MatrixRainEngine.rainConfig.primaryColor;
            document.getElementById('secondaryColor').value = MatrixRainEngine.rainConfig.secondaryColor;
            document.getElementById('characterSet').value = MatrixRainEngine.rainConfig.characterSet;
            document.getElementById('rainDirection').value = MatrixRainEngine.rainConfig.direction;
            
            // Update pattern button
            document.querySelectorAll('.pattern-btn').forEach(btn => btn.classList.remove('active'));
            const patternBtn = document.querySelector(`[onclick="setRainPattern('${MatrixRainEngine.rainConfig.pattern}')"]`);
            if (patternBtn) patternBtn.classList.add('active');
            
            // Log chaos results
            MatrixRainEngine.logActivity(`üåÄ CHAOS: Pattern=${MatrixRainEngine.rainConfig.pattern}, Speed=${MatrixRainEngine.rainConfig.speed}, CharSet=${MatrixRainEngine.rainConfig.characterSet}`, 'success');
            
            // Update animation
            updateRainConfig();
            
            // Create visual chaos effect
            createChaosEffect();
        }
        
        function createChaosEffect() {
            // Create temporary visual chaos
            const canvas = document.getElementById('matrixRainCanvas');
            const ctx = canvas.getContext('2d');
            
            // Flash effect
            let flashCount = 0;
            const flashInterval = setInterval(() => {
                ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.3)`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                flashCount++;
                if (flashCount >= 5) {
                    clearInterval(flashInterval);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }, 100);
        }
        
        // === AUTO ORCHESTRATOR - Simple RNG automation ===
        let autoOrchestratorInterval = null;
        let autoOrchestratorActive = false;
        window.autoOrchestratorActive = false; // Expose globally for Ollama integration
        
        function toggleAutoOrchestrator() {
            autoOrchestratorActive = !autoOrchestratorActive;
            window.autoOrchestratorActive = autoOrchestratorActive; // Sync global
            const btn = document.getElementById('autoOrchestratorBtn');

            if (autoOrchestratorActive) {
                btn.textContent = '‚è∏Ô∏è STOP AUTO';
                btn.style.background = '#ff4444';
                startAutoOrchestrator();
                MatrixRainEngine.logActivity('üé≠ Auto Orchestrator STARTED - continuous random evolution!', 'success');
                updateModeButtons('orchestrator'); // Disable other mode buttons
            } else {
                btn.textContent = 'üé≠ AUTO ORCHESTRATOR';
                btn.style.background = '#0080ff';
                stopAutoOrchestrator();
                MatrixRainEngine.logActivity('üé≠ Auto Orchestrator STOPPED', 'info');
                updateModeButtons(null); // Re-enable all buttons
            }
        }
        
        function startAutoOrchestrator() {
            // Run first change immediately
            orchestrateRandomChange();
            
            // Then schedule recurring changes
            scheduleNextChange();
        }
        
        function scheduleNextChange() {
            if (!autoOrchestratorActive) return;
            
            // Random interval: 8-15 seconds (longer to enjoy each scene)
            const interval = 8000 + Math.floor(Math.random() * 7000);
            const seconds = Math.round(interval / 1000);
            
            console.log(`‚è±Ô∏è Next orchestrator change in ${seconds} seconds...`);
            MatrixRainEngine.logActivity(`‚è±Ô∏è Next change in ${seconds}s`, 'info');
            
            autoOrchestratorInterval = setTimeout(() => {
                orchestrateRandomChange();
                scheduleNextChange(); // Schedule next one
            }, interval);
        }
        
        function orchestrateRandomChange() {
            if (!autoOrchestratorActive) return;
            
            console.log('üé≠ ORCHESTRATOR: Running change cycle...');
            
            // Store previous pattern to detect changes
            const previousPattern = MatrixRainEngine.rainConfig.pattern;
            const previousDirection = MatrixRainEngine.rainConfig.direction;
            
            // All available patterns
            const patterns = ['classic', 'rainbow', 'pentad', 'chaos', 'harmonic', 'particles'];
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8000', '#8000ff', '#00ff41'];
            const characterSets = ['matrix', 'binary', 'hex', 'symbols', 'katakana'];
            const directions = ['down', 'up', 'left', 'right', 'diagonal', 'toward'];
            
            // Randomize EVERYTHING
            const newPattern = patterns[Math.floor(Math.random() * patterns.length)];
            const patternChanged = newPattern !== previousPattern;
            MatrixRainEngine.rainConfig.pattern = newPattern;
            MatrixRainEngine.rainConfig.primaryColor = colors[Math.floor(Math.random() * colors.length)];
            MatrixRainEngine.rainConfig.secondaryColor = colors[Math.floor(Math.random() * colors.length)];
            MatrixRainEngine.rainConfig.speed = 20 + Math.floor(Math.random() * 70); // 20-90
            MatrixRainEngine.rainConfig.intensity = 40 + Math.floor(Math.random() * 60); // 40-100
            MatrixRainEngine.rainConfig.density = 30 + Math.floor(Math.random() * 70); // 30-100
            MatrixRainEngine.rainConfig.characterSet = characterSets[Math.floor(Math.random() * characterSets.length)];
            const newDirection = directions[Math.floor(Math.random() * directions.length)];

            // Reinitialize drop positions when switching to/from horizontal
            if (matrixCanvas && matrixDrops && previousDirection !== newDirection) {
                const fontSize = MatrixRainEngine.rainConfig.fontSize;
                const wasHorizontal = (previousDirection === 'left' || previousDirection === 'right');
                const isHorizontal = (newDirection === 'left' || newDirection === 'right');

                if (wasHorizontal !== isHorizontal) {
                    // Switching orientation - reinitialize all drops
                    const columns = Math.floor(matrixCanvas.width / fontSize);
                    for (let i = 0; i < columns; i++) {
                        if (isHorizontal) {
                            // Going horizontal: randomize X positions across full width
                            matrixDrops[i] = Math.random() * (matrixCanvas.width / fontSize);
                        } else {
                            // Going vertical: randomize Y positions across full height
                            matrixDrops[i] = Math.random() * (matrixCanvas.height / fontSize);
                        }
                    }
                }
            }

            MatrixRainEngine.rainConfig.direction = newDirection;

            // 60% chance to toggle reverse flow for dynamic reversals!
            if (Math.random() < 0.6) {
                reverseFlowMultiplier *= -1;
                const flowStatus = reverseFlowMultiplier === -1 ? '‚è™ REVERSED' : '‚è© FORWARD';
                MatrixRainEngine.logActivity(`üîÑ Flow reversal: ${flowStatus}`, 'success');

                // Update reverse flow button UI
                const btn = document.getElementById('reverseFlowBtn');
                if (btn) {
                    if (reverseFlowMultiplier === -1) {
                        btn.textContent = '‚è© FORWARD FLOW';
                        btn.style.background = '#00ff88';
                    } else {
                        btn.textContent = '‚è™ REVERSE FLOW';
                        btn.style.background = '#ffaa00';
                    }
                }
            }

            // Update UI to reflect changes
            document.getElementById('rainSpeed').value = 101 - MatrixRainEngine.rainConfig.speed;
            document.getElementById('rainIntensity').value = MatrixRainEngine.rainConfig.intensity;
            document.getElementById('rainDensity').value = MatrixRainEngine.rainConfig.density;
            document.getElementById('primaryColor').value = MatrixRainEngine.rainConfig.primaryColor;
            document.getElementById('secondaryColor').value = MatrixRainEngine.rainConfig.secondaryColor;
            document.getElementById('characterSet').value = MatrixRainEngine.rainConfig.characterSet;
            document.getElementById('rainDirection').value = MatrixRainEngine.rainConfig.direction;
            
            // Update active pattern button
            document.querySelectorAll('.pattern-btn').forEach(btn => btn.classList.remove('active'));
            const patternBtn = document.querySelector(`[onclick="setRainPattern('${MatrixRainEngine.rainConfig.pattern}')"]`);
            if (patternBtn) patternBtn.classList.add('active');
            
            // Log the changes with CLEAR visibility
            const directionChanged = MatrixRainEngine.rainConfig.direction !== previousDirection;
            console.log(`\n========================================`);
            console.log(`üé≠ ORCHESTRATOR CHANGE:`);
            console.log(`   Pattern: ${previousPattern} ‚Üí ${MatrixRainEngine.rainConfig.pattern}`);
            console.log(`   Direction: ${previousDirection} ‚Üí ${MatrixRainEngine.rainConfig.direction}`);
            console.log(`   Reverse Flow: ${reverseFlowMultiplier === -1 ? '‚è™ REWINDING' : '‚è© FORWARD'}`);
            console.log(`========================================\n`);
            
            // Show direction change notification
            if (directionChanged) {
                MatrixRainEngine.logActivity(`‚ÜóÔ∏è DIRECTION CHANGED: ${previousDirection} ‚Üí ${MatrixRainEngine.rainConfig.direction}`, 'success');
            }
            
            if (patternChanged) {
                MatrixRainEngine.logActivity(`üé≠ NEW Pattern: ${MatrixRainEngine.rainConfig.pattern} | Dir: ${MatrixRainEngine.rainConfig.direction} | ${MatrixRainEngine.rainConfig.characterSet}`, 'success');
            } else {
                MatrixRainEngine.logActivity(`üîÑ Settings update | Dir: ${MatrixRainEngine.rainConfig.direction} | Rev: ${reverseFlowMultiplier === -1 ? 'YES' : 'NO'}`, 'info');
            }
            
            // Always just update config - smooth transitions, no resets!
            updateRainConfig();
        }
        
        function stopAutoOrchestrator() {
            if (autoOrchestratorInterval) {
                clearTimeout(autoOrchestratorInterval);
                autoOrchestratorInterval = null;
            }
        }
        
        // === REVERSE FLOW TOGGLE ===
        function toggleReverseFlow() {
            reverseFlowMultiplier *= -1; // Flip between 1 and -1
            const btn = document.getElementById('reverseFlowBtn');

            if (reverseFlowMultiplier === -1) {
                btn.textContent = '‚è© FORWARD FLOW';
                btn.style.background = '#00ff88';
                MatrixRainEngine.logActivity('‚è™ REVERSE FLOW ACTIVATED - Everything is rewinding!', 'success');
            } else {
                btn.textContent = '‚è™ REVERSE FLOW';
                btn.style.background = '#ffaa00';
                MatrixRainEngine.logActivity('‚è© Forward flow restored', 'info');
            }
        }

        // === AUDIO REACTIVE SYSTEM ===
        let audioContext = null;
        let audioAnalyser = null;
        let audioDataArray = null;
        let audioBufferLength = 0;
        let audioReactiveActive = false;
        window.audioReactiveActive = false; // Expose globally for Ollama integration
        let audioAnimationFrame = null;
        let audioStream = null;

        // Syllable detection state (for reversals)
        let syllableDetector = {
            threshold: 1.08,        // Balanced sensitivity
            minVolume: 0.06,        // Low but not too low
            lastSyllableTime: 0,
            syllableCooldown: 120,  // 120ms = ~8 syllables/sec (prevents double-reversals)
            volumeHistory: [],
            historyLength: 12,      // Balanced history
            avgVolume: 0
        };

        // Beat detection state (for color changes AND reversal backup)
        let beatDetector = {
            threshold: 1.4,         // Higher threshold for just strong beats
            minBass: 140,          // Only trigger on significant bass
            lastBeatTime: 0,
            beatCooldown: 150,      // Allow more frequent beat reactions
            bassHistory: [],
            historyLength: 15,
            avgBass: 0
        };

        // Track when last syllable was detected (for beat reversal backup)
        let lastSyllableOrBeatReversalTime = 0;

        // Rhythm detection and direction bursts removed
        // Music now controls everything continuously

        async function toggleAudioReactive() {
            audioReactiveActive = !audioReactiveActive;
            window.audioReactiveActive = audioReactiveActive; // Sync global
            const btn = document.getElementById('audioReactiveBtn');
            const status = document.getElementById('audioStatus');

            if (audioReactiveActive) {
                btn.textContent = '‚è∏Ô∏è STOP AUDIO MODE';
                btn.style.background = '#ff4444';
                status.textContent = 'üé§ Requesting audio access...';

                try {
                    // Request desktop/tab audio capture
                    audioStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    // Set up Web Audio API
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    audioAnalyser = audioContext.createAnalyser();
                    audioAnalyser.fftSize = 2048;
                    audioAnalyser.smoothingTimeConstant = 0.2; // REDUCED from 0.8 for ultra-responsive color changes!

                    const source = audioContext.createMediaStreamSource(audioStream);
                    source.connect(audioAnalyser);

                    audioBufferLength = audioAnalyser.frequencyBinCount;
                    audioDataArray = new Uint8Array(audioBufferLength);

                    status.textContent = 'üéµ AUDIO REACTIVE - Syncing with sound!';
                    MatrixRainEngine.logActivity('üéµ Audio Reactive Mode ACTIVATED - Rain synced to audio!', 'success');

                    // Gray out secondary color picker (not used in audio mode)
                    const secondaryColorPicker = document.getElementById('secondaryColor');
                    const secondaryColorLabel = secondaryColorPicker.previousElementSibling;
                    if (secondaryColorPicker) {
                        secondaryColorPicker.style.opacity = '0.3';
                        secondaryColorPicker.style.pointerEvents = 'none';
                        secondaryColorPicker.style.filter = 'grayscale(100%)';
                        secondaryColorPicker.disabled = true;
                    }
                    if (secondaryColorLabel) {
                        secondaryColorLabel.style.opacity = '0.5';
                    }

                    // Start audio analysis loop
                    analyzeAudio();

                    updateModeButtons('audio'); // Disable other mode buttons

                } catch (error) {
                    console.error('Audio capture error:', error);
                    status.textContent = '‚ùå Audio access denied. Try sharing a tab with audio.';
                    audioReactiveActive = false;
                    window.audioReactiveActive = false; // Sync global
                    btn.textContent = 'üéµ AUDIO REACTIVE MODE';
                    btn.style.background = '#ff1493';

                    // Re-enable secondary color picker on error
                    const secondaryColorPicker = document.getElementById('secondaryColor');
                    const secondaryColorLabel = secondaryColorPicker.previousElementSibling;
                    if (secondaryColorPicker) {
                        secondaryColorPicker.style.opacity = '1';
                        secondaryColorPicker.style.pointerEvents = 'auto';
                        secondaryColorPicker.style.filter = 'none';
                        secondaryColorPicker.disabled = false;
                    }
                    if (secondaryColorLabel) {
                        secondaryColorLabel.style.opacity = '1';
                    }

                    updateModeButtons(null); // Re-enable all buttons on error
                }

            } else {
                btn.textContent = 'üéµ AUDIO REACTIVE MODE';
                btn.style.background = '#ff1493';
                status.textContent = '';
                stopAudioReactive();

                // Re-enable secondary color picker
                const secondaryColorPicker = document.getElementById('secondaryColor');
                const secondaryColorLabel = secondaryColorPicker.previousElementSibling;
                if (secondaryColorPicker) {
                    secondaryColorPicker.style.opacity = '1';
                    secondaryColorPicker.style.pointerEvents = 'auto';
                    secondaryColorPicker.style.filter = 'none';
                    secondaryColorPicker.disabled = false;
                }
                if (secondaryColorLabel) {
                    secondaryColorLabel.style.opacity = '1';
                }

                MatrixRainEngine.logActivity('üéµ Audio Reactive Mode STOPPED', 'info');
                updateModeButtons(null); // Re-enable all buttons
            }
        }

        function stopAudioReactive() {
            if (audioAnimationFrame) {
                cancelAnimationFrame(audioAnimationFrame);
                audioAnimationFrame = null;
            }
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            audioAnalyser = null;
            audioDataArray = null;
        }

        function analyzeAudio() {
            if (!audioReactiveActive || !audioAnalyser) return;

            audioAnimationFrame = requestAnimationFrame(analyzeAudio);

            // Get frequency data
            audioAnalyser.getByteFrequencyData(audioDataArray);

            // Calculate different frequency ranges
            const bass = getAverageFrequency(0, 80);      // 0-80: Bass/kick
            const lowMid = getAverageFrequency(80, 200);  // 80-200: Low-mid (music body)
            const mid = getAverageFrequency(200, 600);    // 200-600: Mid (vocals)
            const high = getAverageFrequency(600, 1024);  // 600+: High frequencies (consonants)

            // Overall volume
            const volume = (bass + lowMid + mid + high) / 4 / 255;

            // SYLLABLES = REVERSALS ONLY
            detectSyllables(volume, mid, high);

            // MUSIC = EVERYTHING ELSE (continuous background control)
            reactToAudio(bass, lowMid, mid, high, volume);

            // Draw visualizer
            drawAudioVisualizer(bass, lowMid, mid, high);
        }

        function getAverageFrequency(startBin, endBin) {
            let sum = 0;
            let count = 0;
            for (let i = startBin; i < endBin && i < audioBufferLength; i++) {
                sum += audioDataArray[i];
                count++;
            }
            return count > 0 ? sum / count : 0;
        }

        function detectSyllables(volume, mid, high) {
            const now = Date.now();

            // Update volume history
            syllableDetector.volumeHistory.push(volume);
            if (syllableDetector.volumeHistory.length > syllableDetector.historyLength) {
                syllableDetector.volumeHistory.shift();
            }

            // Calculate average volume
            syllableDetector.avgVolume = syllableDetector.volumeHistory.reduce((a, b) => a + b, 0) / syllableDetector.volumeHistory.length;

            // Detect syllables - HYPER SENSITIVE to catch EVERYTHING
            const isSyllable = volume > syllableDetector.avgVolume * syllableDetector.threshold
                            && volume > syllableDetector.minVolume
                            && mid > 40  // VERY low threshold - catches almost any vocal
                            && (now - syllableDetector.lastSyllableTime) > syllableDetector.syllableCooldown;

            // Also catch consonant pops (high frequency spikes) - LOWER threshold
            const isConsonant = high > 100
                             && (now - syllableDetector.lastSyllableTime) > syllableDetector.syllableCooldown;

            // ALSO catch any significant mid-frequency activity (vocals)
            const isVocal = mid > 120
                         && (now - syllableDetector.lastSyllableTime) > syllableDetector.syllableCooldown;

            if (isSyllable || isConsonant || isVocal) {
                syllableDetector.lastSyllableTime = now;
                onSyllableDetected();
            }
        }

        function detectBeats(bass) {
            const now = Date.now();

            // Update bass history
            beatDetector.bassHistory.push(bass);
            if (beatDetector.bassHistory.length > beatDetector.historyLength) {
                beatDetector.bassHistory.shift();
            }

            // Calculate average bass
            beatDetector.avgBass = beatDetector.bassHistory.reduce((a, b) => a + b, 0) / beatDetector.bassHistory.length;

            // Detect bass beats - focus on low frequencies only
            const isBeat = bass > beatDetector.avgBass * beatDetector.threshold
                        && bass > beatDetector.minBass
                        && (now - beatDetector.lastBeatTime) > beatDetector.beatCooldown;

            if (isBeat) {
                beatDetector.lastBeatTime = now;
                onBeatDetected(bass);
            }
        }

        // Rhythm change detection removed - music now controls everything continuously

        function onSyllableDetected() {
            // REVERSE FLOW on EVERY syllable!
            reverseFlowMultiplier *= -1;
            lastSyllableOrBeatReversalTime = Date.now(); // Track this reversal
            const flowStatus = reverseFlowMultiplier === -1 ? '‚è™' : '‚è©';

            // Update button UI
            const btn = document.getElementById('reverseFlowBtn');
            if (btn) {
                if (reverseFlowMultiplier === -1) {
                    btn.textContent = '‚è© FORWARD FLOW';
                    btn.style.background = '#00ff88';
                } else {
                    btn.textContent = '‚è™ REVERSE FLOW';
                    btn.style.background = '#ffaa00';
                }
            }

            // Log only occasionally to avoid spam
            if (Math.random() < 0.05) { // 5% logged
                MatrixRainEngine.logActivity(`${flowStatus} syllable`, 'info');
            }
        }

        function onBeatDetected(bass) {
            const now = Date.now();
            const timeSinceLastReversal = now - lastSyllableOrBeatReversalTime;

            // If no syllable in last 500ms, use BEAT for reversal (backup mode)
            if (timeSinceLastReversal > 500) {
                reverseFlowMultiplier *= -1;
                lastSyllableOrBeatReversalTime = now;
                const flowStatus = reverseFlowMultiplier === -1 ? '‚è™' : '‚è©';

                // Update button UI
                const btn = document.getElementById('reverseFlowBtn');
                if (btn) {
                    if (reverseFlowMultiplier === -1) {
                        btn.textContent = '‚è© FORWARD FLOW';
                        btn.style.background = '#00ff88';
                    } else {
                        btn.textContent = '‚è™ REVERSE FLOW';
                        btn.style.background = '#ffaa00';
                    }
                }

                // Log occasionally
                if (Math.random() < 0.1) {
                    MatrixRainEngine.logActivity(`${flowStatus} beat (backup)`, 'info');
                }
            }
            // Note: Color is now controlled continuously by reactToAudio (lowMid frequency)
            // No more beat-triggered color flashes - smoother color evolution
        }

        function onRhythmChange(bass, lowMid, mid, high, changeAmount) {
            // This function is now REMOVED from active use
            // Music drives everything continuously via reactToAudio()
        }

        // Helper function to convert HSL to HEX for color pickers
        function hslToHex(h, s, l) {
            s /= 100;
            l /= 100;
            const a = s * Math.min(l, 1 - l);
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        function reactToAudio(bass, lowMid, mid, high, volume) {
            const config = MatrixRainEngine.rainConfig;

            // === INTELLIGENT AUDIO-TO-VISUAL MAPPING ===
            // Each audio frequency controls ONE specific visual parameter

            // FORCE CLASSIC PATTERN (only one that shows color changes properly)
            config.pattern = 'classic';
            document.querySelectorAll('.pattern-btn').forEach(btn => btn.classList.remove('active'));
            const classicBtn = document.querySelector(`[onclick="setRainPattern('classic')"]`);
            if (classicBtn) classicBtn.classList.add('active');

            // BASS ‚Üí SPEED (more bass = faster rain)
            const bassNormalized = bass / 255;
            config.speed = 15 + Math.floor(bassNormalized * 75); // 15-90

            // LOW-MID + MID ‚Üí COLOR HUE (MAXIMUM sensitivity to musical notes)
            // HYPER ENHANCED: Each note in a scale (do-re-mi-fa-so-la-ti-do) gets its own color!
            // Musical notes are in 200-600Hz range, so we focus heavily on mid frequencies

            // Weight mid frequencies MORE heavily (where vocals/melody live)
            const lowMidNormalized = lowMid / 255;
            const midNormalized = mid / 255;

            // MAXIMUM SENSITIVITY: power of 0.15 makes TINY pitch differences create HUGE color shifts!
            // This is EXTREME - every subtle vocal tone change will be visible
            const lowMidSensitive = Math.pow(lowMidNormalized, 0.15);
            const midSensitive = Math.pow(midNormalized, 0.15);

            // Combine with HEAVY emphasis on mid frequencies (70% mid, 30% lowMid)
            // Maximum focus on the exact frequencies where sung notes exist
            const combinedColorControl = (midSensitive * 0.7) + (lowMidSensitive * 0.3);

            // AGGRESSIVE multiplier to spread colors across the FULL spectrum
            // This ensures each semitone gets a visually distinct color
            const hueMultiplier = 2.5; // MAXIMUM color spread!
            let hue = Math.floor(combinedColorControl * 360 * hueMultiplier) % 360;

            // Add MORE high-frequency modulation for extra texture variation
            const highModulation = Math.floor((high / 255) * 50) - 25; // -25 to +25 degrees
            hue = (hue + highModulation + 360) % 360;

            // Maximum saturation: keep colors VIVID
            const saturation = 85 + Math.floor((midNormalized * 15)); // 85-100% saturation

            // Dynamic lightness: keeps colors vibrant and eye-popping
            const lightness = 40 + Math.floor((volume * 20)); // 40-60% lightness for maximum vibrancy

            config.primaryColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            const compHue = (hue + 180) % 360;
            config.secondaryColor = `hsl(${compHue}, ${saturation}%, ${lightness}%)`;

            // Update color pickers
            const primaryHex = hslToHex(hue, saturation, lightness);
            const secondaryHex = hslToHex(compHue, saturation, lightness);
            document.getElementById('primaryColor').value = primaryHex;
            document.getElementById('secondaryColor').value = secondaryHex;

            // MID ‚Üí DENSITY (vocal/melody range controls how much rain)
            // midNormalized already declared above
            config.density = 20 + Math.floor(midNormalized * 80); // 20-100

            // HIGH ‚Üí CHARACTER SET (high frequencies pick character complexity)
            const highNormalized = high / 255;
            const charIndex = Math.floor(highNormalized * 5); // 0-4
            const characterSets = ['matrix', 'binary', 'hex', 'symbols', 'katakana'];
            config.characterSet = characterSets[Math.min(charIndex, 4)];
            document.getElementById('characterSet').value = config.characterSet;

            // OVERALL VOLUME ‚Üí INTENSITY (loudness = brightness)
            config.intensity = 30 + Math.floor(volume * 70); // 30-100

            // BASS + HIGH COMBO ‚Üí DIRECTION (bass OR high energy changes direction)
            // Very low threshold to catch musical moments!
            const directionTrigger = bass > 60 || high > 90 || lowMid > 100;
            if (directionTrigger) {
                const directions = ['down', 'up', 'left', 'right', 'diagonal', 'toward'];
                // Use combined audio energy to pick direction
                const dirValue = (bass + high + lowMid) / 3;
                const dirIndex = Math.floor((dirValue / 255) * directions.length);
                const newDirection = directions[Math.min(dirIndex, 4)];
                const oldDirection = config.direction;

                // Reinitialize drop positions when switching to/from horizontal
                if (matrixCanvas && matrixDrops && oldDirection !== newDirection) {
                    const fontSize = config.fontSize;
                    const wasHorizontal = (oldDirection === 'left' || oldDirection === 'right');
                    const isHorizontal = (newDirection === 'left' || newDirection === 'right');

                    if (wasHorizontal !== isHorizontal) {
                        // Switching orientation - reinitialize all drops
                        const columns = Math.floor(matrixCanvas.width / fontSize);
                        for (let i = 0; i < columns; i++) {
                            if (isHorizontal) {
                                // Going horizontal: randomize X positions across full width
                                matrixDrops[i] = Math.random() * (matrixCanvas.width / fontSize);
                            } else {
                                // Going vertical: randomize Y positions across full height
                                matrixDrops[i] = Math.random() * (matrixCanvas.height / fontSize);
                            }
                        }
                    }
                }

                config.direction = newDirection;
                document.getElementById('rainDirection').value = config.direction;

                // Also update Ollama message direction if Ollama is active
                if (window.OllamaSystem && window.OllamaSystem.active && window.OllamaSystem.messageActive) {
                    window.OllamaSystem.direction = newDirection;
                }
            }

            // Update UI sliders
            document.getElementById('rainSpeed').value = 101 - config.speed;
            document.getElementById('rainDensity').value = config.density;
            document.getElementById('rainIntensity').value = config.intensity;
        }

        function drawAudioVisualizer(bass, lowMid, mid, high) {
            const visualizer = document.getElementById('audioVisualizer');
            if (!visualizer) return;

            // Create frequency bars
            const bassHeight = (bass / 255) * 100;
            const lowMidHeight = (lowMid / 255) * 100;
            const midHeight = (mid / 255) * 100;
            const highHeight = (high / 255) * 100;

            visualizer.innerHTML = `
                <div style="position: absolute; bottom: 0; left: 10%; width: 15%; height: ${bassHeight}%; background: linear-gradient(to top, #ff0000, #ff6060); transition: height 0.05s;"></div>
                <div style="position: absolute; bottom: 0; left: 30%; width: 15%; height: ${lowMidHeight}%; background: linear-gradient(to top, #ff8000, #ffaa60); transition: height 0.05s;"></div>
                <div style="position: absolute; bottom: 0; left: 50%; width: 15%; height: ${midHeight}%; background: linear-gradient(to top, #00ff00, #60ff60); transition: height 0.05s;"></div>
                <div style="position: absolute; bottom: 0; left: 70%; width: 15%; height: ${highHeight}%; background: linear-gradient(to top, #0080ff, #60a0ff); transition: height 0.05s;"></div>
                <div style="position: absolute; top: 5px; left: 10%; font-size: 10px; color: #ff6060;">BASS‚ÜíSpeed</div>
                <div style="position: absolute; top: 5px; left: 30%; font-size: 10px; color: #ffaa60;">LOW‚ÜíColor</div>
                <div style="position: absolute; top: 5px; left: 50%; font-size: 10px; color: #60ff60;">MID‚ÜíDensity</div>
                <div style="position: absolute; top: 5px; left: 70%; font-size: 10px; color: #60a0ff;">HIGH‚ÜíChars</div>
            `;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üåÄ OLLAMA MATRIX RAIN TRANSLATION SYSTEM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const OllamaSystem = {
            // State
            active: false,
            ws: null,
            wsUrl: 'ws://localhost:8080',
            reconnectInterval: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 10,

            // Canvas elements
            msgCanvas: null,
            msgCtx: null,

            // Message state
            messageActive: false,
            messageColumns: [],
            messageStartTime: 0,
            messageDuration: 0,
            breathPhase: 'baseline', // baseline, inhale, expression, exhale
            lastChunkTime: 0,
            streamResetTimeout: null,

            // Visual parameters
            currentMode: 'normal', // ambient, normal, emphasis, urgent, emergency
            urgencyLevel: 3,
            backgroundRainColor: '#00ff41',
            messageColor: '#ffff00',
            contrast: 0.6,

            // Initialize Ollama system
            init() {
                console.log('üåÄ Ollama System: Initializing...');

                // Get message canvas
                this.msgCanvas = document.getElementById('ollamaMessageCanvas');
                if (!this.msgCanvas) {
                    console.error('üåÄ Ollama System: Message canvas not found!');
                    return;
                }
                this.msgCtx = this.msgCanvas.getContext('2d');

                // Set canvas size
                this.msgCanvas.width = window.innerWidth;
                this.msgCanvas.height = window.innerHeight;

                // Resize handler
                window.addEventListener('resize', () => {
                    if (this.msgCanvas) {
                        this.msgCanvas.width = window.innerWidth;
                        this.msgCanvas.height = window.innerHeight;
                    }
                });

                console.log('üåÄ Ollama System: Ready');
            },

            // Connect to WebSocket server
            connect() {
                // Check if already connected or connecting
                if (this.ws) {
                    if (this.ws.readyState === WebSocket.OPEN) {
                        console.log('üåÄ Ollama System: Already connected');
                        return;
                    }
                    if (this.ws.readyState === WebSocket.CONNECTING) {
                        console.log('üåÄ Ollama System: Connection already in progress');
                        return;
                    }
                    // Close any existing connection before creating new one
                    if (this.ws.readyState !== WebSocket.CLOSED) {
                        console.log('üåÄ Ollama System: Closing previous connection');
                        this.ws.close();
                    }
                }

                try {
                    console.log(`üåÄ Ollama System: Connecting to ${this.wsUrl}...`);
                    this.ws = new WebSocket(this.wsUrl);

                    this.ws.onopen = () => {
                        console.log('üåÄ Ollama System: WebSocket connected!');
                        this.reconnectAttempts = 0;
                        this.updateStatus('‚úÖ Connected to Ollama Bridge');

                        if (this.reconnectInterval) {
                            clearInterval(this.reconnectInterval);
                            this.reconnectInterval = null;
                        }

                        // Send hello message
                        this.send({ type: 'hello', client: 'matrix-rain' });
                    };

                    this.ws.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };

                    this.ws.onerror = (error) => {
                        console.error('üåÄ Ollama System: WebSocket error', error);
                        this.updateStatus('‚ùå Connection error');
                    };

                    this.ws.onclose = () => {
                        console.log('üåÄ Ollama System: WebSocket disconnected');
                        this.updateStatus('‚ö†Ô∏è Disconnected - Reconnecting...');

                        // Attempt reconnection
                        if (this.active && this.reconnectAttempts < this.maxReconnectAttempts) {
                            if (!this.reconnectInterval) {
                                this.reconnectInterval = setInterval(() => {
                                    this.reconnectAttempts++;
                                    console.log(`üåÄ Ollama System: Reconnect attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                                    this.connect();
                                }, 3000);
                            }
                        } else if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                            this.updateStatus('‚ùå Connection failed - Server not running?');
                            console.error('üåÄ Ollama System: Max reconnect attempts reached');
                        }
                    };

                } catch (error) {
                    console.error('üåÄ Ollama System: Failed to connect', error);
                    this.updateStatus('‚ùå Failed to connect');
                }
            },

            // Disconnect WebSocket
            disconnect() {
                if (this.reconnectInterval) {
                    clearInterval(this.reconnectInterval);
                    this.reconnectInterval = null;
                }

                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }

                this.updateStatus('Disconnected');
                console.log('üåÄ Ollama System: Disconnected');
            },

            // Send message to server
            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                } else {
                    console.warn('üåÄ Ollama System: Cannot send - not connected');
                }
            },

            // Handle incoming WebSocket message
            handleMessage(data) {
                try {
                    const message = JSON.parse(data);
                    console.log('üåÄ Ollama System: Received:', message.type);

                    switch (message.type) {
                        case 'expression':
                            this.triggerExpression(message);
                            break;
                        case 'test':
                            console.log('üåÄ Ollama System: Test message:', message.text);
                            this.triggerExpression({
                                text: message.text,
                                urgency: message.urgency || 3,
                                duration: message.duration || 4000
                            });
                            break;
                        case 'error':
                            console.error('üåÄ Ollama System: Error:', message.text);
                            // Display error in rain too
                            this.triggerExpression({
                                text: message.text,
                                urgency: 9,
                                duration: 5000
                            });
                            break;
                        default:
                            console.log('üåÄ Ollama System: Unknown message type:', message.type);
                    }

                } catch (error) {
                    console.error('üåÄ Ollama System: Error parsing message', error);
                }
            },

            // Trigger message expression
            triggerExpression(params) {
                console.log(`üåÄ Ollama System: Expression triggered - "${params.text}"`);

                // Update visual parameters based on urgency AND message content
                this.urgencyLevel = params.urgency || 3;
                this.applyUrgencyMode(this.urgencyLevel, params.text);

                // Handle streaming vs full messages
                if (params.streaming) {
                    // Clear any pending reset timeout
                    if (this.streamResetTimeout) {
                        clearTimeout(this.streamResetTimeout);
                    }

                    // Check if this is a new stream starting (no recent chunks)
                    const timeSinceLastChunk = Date.now() - this.lastChunkTime;
                    if (timeSinceLastChunk > 5000) {
                        // New message starting - clear old one
                        console.log('üåÄ Ollama System: New stream detected, clearing old message');
                        this.messageChars = [];
                    }

                    // Streaming mode: accumulate characters
                    if (!this.messageChars) {
                        this.messageChars = [];
                    }
                    // Add new characters from this chunk
                    const newChars = (params.text || '').split('');
                    this.messageChars.push(...newChars);
                    console.log(`üåÄ Ollama System: Added ${newChars.length} chars, total now ${this.messageChars.length}`);

                    // Update last chunk time
                    this.lastChunkTime = Date.now();

                    // Set timeout to mark stream as complete after 2 seconds of no new chunks
                    // (but keep displaying the message in a loop)
                    this.streamResetTimeout = setTimeout(() => {
                        console.log('üåÄ Ollama System: Stream complete, message will continue looping until next message');
                        // Message keeps looping - don't clear anything
                    }, 2000);
                } else {
                    // Non-streaming: replace entire message
                    this.messageChars = (params.text || '').split('');
                    console.log(`üåÄ Ollama System: Message has ${this.messageChars.length} characters`);
                }

                // Skip if no characters
                if (!this.messageChars || this.messageChars.length === 0) {
                    console.log('üåÄ Ollama System: No characters to display, skipping');
                    return;
                }

                // Calculate columns
                const fontSize = MatrixRainEngine.rainConfig.fontSize || 14;
                const columns = Math.floor(this.msgCanvas.width / fontSize);

                // ALL columns show the LLM message
                const numMessageColumns = columns;
                const messageColumnIndices = [];

                // Use all columns
                for (let i = 0; i < columns; i++) {
                    messageColumnIndices.push(i);
                }

                // Store globally so background rain can skip these columns
                window.ollamaMessageColumns = new Set(messageColumnIndices);

                this.messageColumns = messageColumnIndices.map(colIndex => {
                    // Use the same dropSpeed from background rain for this column (if available)
                    const bgSpeed = window.dropSpeeds && window.dropSpeeds[colIndex]
                        ? window.dropSpeeds[colIndex]
                        : (0.7 + Math.random() * 0.6);

                    return {
                        column: colIndex,
                        yPos: Math.random() * -50, // Random start position
                        speed: bgSpeed * (this.speedMultiplier || 1.0),
                        charOffset: 0 // Track which character in message to show
                    };
                });

                // Calculate contrasting color for background rain
                const contrastColor = this.getContrastingColor(this.messageColor);

                // Update background rain ONLY if audio reactive mode is NOT active
                // When audio is active, it controls direction and colors
                if (!window.audioReactiveActive) {
                    MatrixRainEngine.rainConfig.direction = this.direction;
                    MatrixRainEngine.rainConfig.primaryColor = contrastColor;
                    console.log(`üåÄ Ollama System: Background rain direction: ${this.direction}, color: ${contrastColor}`);
                } else {
                    console.log(`üåÄ Ollama System: Audio mode active - audio controls direction/colors`);
                }

                // Start expression cycle (indefinite until next message)
                this.messageActive = true;
                this.breathPhase = 'expression';

                // Show message canvas
                this.msgCanvas.style.display = 'block';

                console.log(`üåÄ Ollama System: ALL ${columns} columns showing LLM message, urgency ${this.urgencyLevel}, mode ${this.currentMode}`);
            },

            // Calculate contrasting color
            getContrastingColor(hexColor) {
                // Convert hex to RGB
                const hex = hexColor.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;

                // Convert to HSL
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }

                // Get contrasting hue with variety (not always complementary)
                // Choose from: triadic (120¬∞), complementary (180¬∞), split-complementary (150¬∞ or 210¬∞), or analogous contrast (90¬∞ or 270¬∞)
                const hueOffsets = [90, 120, 150, 180, 210, 270];
                const randomOffset = hueOffsets[Math.floor(Math.random() * hueOffsets.length)];
                const contrastHue = ((h * 360) + randomOffset) % 360;

                // Vary saturation and lightness for more variety
                const saturation = 80 + Math.floor(Math.random() * 20); // 80-100%
                const lightness = 45 + Math.floor(Math.random() * 10);  // 45-55%

                // Return as HSL string
                return `hsl(${contrastHue}, ${saturation}%, ${lightness}%)`;
            },

            // Apply urgency mode visual parameters
            applyUrgencyMode(urgency, text = '') {
                // Detect message characteristics
                const hasQuestion = text.includes('?');
                const hasExclamation = text.includes('!');
                const hasEllipsis = text.includes('...');
                const isAllCaps = text === text.toUpperCase() && text.length > 10;

                // RANDOMIZE COLOR - pick from vibrant palette
                const vibrantColors = [
                    '#ff0000', // Red
                    '#ff00ff', // Magenta
                    '#00ffff', // Cyan
                    '#ffff00', // Yellow
                    '#00ff00', // Green
                    '#ff8000', // Orange
                    '#8000ff', // Purple
                    '#00ff88', // Mint
                    '#ff0088', // Pink
                    '#88ff00'  // Lime
                ];
                this.messageColor = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];

                // RANDOMIZE PATTERN - all patterns except particles and chaos (unless audio mode overrides)
                if (!window.audioReactiveActive && !window.autoOrchestratorActive) {
                    const ollamaCompatiblePatterns = ['classic', 'rainbow', 'pentad', 'harmonic'];
                    const randomPattern = ollamaCompatiblePatterns[Math.floor(Math.random() * ollamaCompatiblePatterns.length)];
                    MatrixRainEngine.rainConfig.pattern = randomPattern;

                    // Update UI buttons to show active pattern
                    document.querySelectorAll('.pattern-btn').forEach(btn => btn.classList.remove('active'));
                    const activeBtn = document.querySelector(`.pattern-btn[onclick*="${randomPattern}"]`);
                    if (activeBtn) activeBtn.classList.add('active');

                    console.log(`üåÄ Ollama System: Pattern changed to ${randomPattern}`);
                }

                if (urgency >= 8) {
                    // URGENT MODE - Fast, toward camera or down
                    this.currentMode = 'urgent';
                    this.contrast = 1.0;
                    this.direction = 'down'; // Aggressive downward
                    this.speedMultiplier = 2.0; // Double speed!
                    console.log('üåÄ Ollama System: URGENT mode activated - FAST DOWN');

                } else if (urgency >= 6) {
                    // EMPHASIS MODE - Moderate speed, varied direction
                    this.currentMode = 'emphasis';
                    this.contrast = 0.8;

                    if (hasQuestion) {
                        this.direction = 'up'; // Questions rise
                        console.log('üåÄ Ollama System: EMPHASIS mode - UPWARD (question)');
                    } else if (hasExclamation) {
                        this.direction = 'right'; // Excitement moves forward
                        console.log('üåÄ Ollama System: EMPHASIS mode - RIGHT (excited)');
                    } else {
                        this.direction = 'down';
                        console.log('üåÄ Ollama System: EMPHASIS mode - DOWN');
                    }
                    this.speedMultiplier = 1.5;

                } else if (urgency >= 3) {
                    // NORMAL MODE - Standard flow
                    this.currentMode = 'normal';
                    this.contrast = 0.6;

                    if (hasQuestion) {
                        this.direction = 'up'; // Questions seek
                        this.speedMultiplier = 1.0;
                        console.log('üåÄ Ollama System: NORMAL mode - UPWARD (question)');
                    } else if (hasEllipsis) {
                        this.direction = 'diagonal'; // Uncertainty drifts
                        this.speedMultiplier = 0.8;
                        console.log('üåÄ Ollama System: NORMAL mode - DIAGONAL (uncertain)');
                    } else {
                        this.direction = 'down'; // Statements ground
                        this.speedMultiplier = 1.0;
                        console.log('üåÄ Ollama System: NORMAL mode - DOWN (statement)');
                    }

                } else {
                    // AMBIENT MODE - Slow, dreamy
                    this.currentMode = 'ambient';
                    this.contrast = 0.3;
                    this.direction = 'down';
                    this.speedMultiplier = 0.5; // Half speed, whisper
                    console.log('üåÄ Ollama System: AMBIENT mode - SLOW DOWN');
                }
            },

            // Draw message layer (called from animation loop)
            drawMessageLayer() {
                if (!this.messageActive || !this.messageChars || this.messageChars.length === 0) return;

                // Clear canvas to transparency (background rain shows through)
                this.msgCtx.clearRect(0, 0, this.msgCanvas.width, this.msgCanvas.height);

                const baseFontSize = MatrixRainEngine.rainConfig.fontSize || 14;
                const messageFontSize = baseFontSize; // Same size as user messages for equality
                this.msgCtx.font = `${messageFontSize}px monospace`;
                const dir = this.direction || 'down';
                const trailLength = 14; // Longer trail for better readability (was 8)

                // Draw ONLY the selected message columns (not all columns!)
                this.messageColumns.forEach(col => {
                    // Get current character index from message (cycling through)
                    const baseCharIndex = Math.floor(col.charOffset) % this.messageChars.length;

                    // Calculate wrap distance
                    const maxDist = (dir === 'right' || dir === 'left')
                        ? this.msgCanvas.width / messageFontSize
                        : this.msgCanvas.height / messageFontSize;

                    // Draw trail at BOTH positions during wrap (arcade game style)
                    const positions = [col.yPos];

                    // If near edge, also draw wrapped position
                    if (col.yPos < trailLength) {
                        positions.push(col.yPos + maxDist);
                    }
                    if (col.yPos > maxDist - trailLength) {
                        positions.push(col.yPos - maxDist);
                    }

                    positions.forEach(yPos => {
                        let baseX, baseY;

                        // Calculate base position based on direction (use messageFontSize for smooth positioning)
                        // Round to integers to prevent jitter from sub-pixel rendering
                        if (dir === 'up' || dir === 'down') {
                            // VERTICAL
                            baseX = Math.round(col.column * baseFontSize + (messageFontSize - baseFontSize) / 2); // Center in column
                            baseY = Math.round(yPos * messageFontSize);
                        } else if (dir === 'right' || dir === 'left') {
                            // HORIZONTAL
                            baseX = Math.round(yPos * messageFontSize);
                            baseY = Math.round(col.column * baseFontSize + (messageFontSize - baseFontSize) / 2); // Center in row
                        } else if (dir === 'diagonal') {
                            // DIAGONAL
                            baseX = Math.round(col.column * baseFontSize + yPos * messageFontSize * 0.5 + (messageFontSize - baseFontSize) / 2);
                            baseY = Math.round(yPos * messageFontSize);
                        }

                        // Draw trail: each position is EXACTLY messageFontSize apart (no gaps)
                        for (let i = 0; i < trailLength; i++) {
                            const opacity = (1 - (i / trailLength));

                            // Calculate trail position (each character is messageFontSize behind previous)
                            // Round to integers to prevent jitter
                            let trailX = baseX;
                            let trailY = baseY;

                            if (dir === 'up' || dir === 'down') {
                                trailY = Math.round(baseY + (i * messageFontSize * (dir === 'up' ? 1 : -1)));
                            } else if (dir === 'right' || dir === 'left') {
                                trailX = Math.round(baseX + (i * messageFontSize * (dir === 'right' ? -1 : 1)));
                            } else if (dir === 'diagonal') {
                                trailX = Math.round(baseX - (i * messageFontSize * 0.5));
                                trailY = Math.round(baseY - (i * messageFontSize));
                            }

                            // Get character for this trail position (cycle through message)
                            const charIndex = (baseCharIndex - i + this.messageChars.length) % this.messageChars.length;
                            const char = this.messageChars[charIndex];

                            // Apply pattern-specific coloring
                            const currentPattern = MatrixRainEngine.rainConfig.pattern;
                            let charColor = this.messageColor; // Default

                            if (currentPattern === 'rainbow') {
                                const rainbowColors = ['#ff0000', '#ff8000', '#ffff00', '#00ff00', '#0080ff', '#8000ff', '#ff0080'];
                                const colorIndex = Math.floor((col.column + Date.now() / 100) % rainbowColors.length);
                                charColor = rainbowColors[colorIndex];
                            } else if (currentPattern === 'pentad') {
                                const pentadColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
                                charColor = pentadColors[col.column % 5];
                            } else if (currentPattern === 'harmonic') {
                                const hue = 120 + Math.sin(Date.now() / 2000 + col.column * 0.05) * 60;
                                charColor = `hsl(${hue}, 100%, 50%)`;

                                // Add harmonic wave motion
                                const wave = Math.sin(Date.now() / 1000 + col.column * 0.1) * 5;
                                if (dir === 'up' || dir === 'down') {
                                    trailX += wave;
                                } else {
                                    trailY += wave;
                                }
                            }

                            // Draw character
                            this.msgCtx.fillStyle = charColor;
                            this.msgCtx.globalAlpha = opacity;
                            this.msgCtx.fillText(char, trailX, trailY);
                        }
                    });

                    // Move drop (match background rain mechanics) - Round to prevent jitter
                    col.yPos = Math.round(col.yPos + col.speed * (dir === 'up' ? -1 : 1));

                    // Update character offset (how far through message we've scrolled) - Round to prevent jitter
                    col.charOffset = Math.round(col.charOffset + col.speed);

                    // Seamless wrap around (match background rain exactly)
                    while (col.yPos < 0) col.yPos += maxDist;
                    while (col.yPos > maxDist) col.yPos -= maxDist;
                });

                // Reset globalAlpha
                this.msgCtx.globalAlpha = 1.0;

                // NO duration limit - stays indefinite until next message
            },

            // End expression cycle (called when new message arrives)
            endExpression() {
                console.log('üåÄ Ollama System: Clearing previous message');
                // Just clear the state - new message will take over
                // Canvas stays visible for continuous flow
            },

            // Update status display
            updateStatus(message) {
                const statusDiv = document.getElementById('ollamaStatus');
                if (statusDiv) {
                    statusDiv.textContent = message;
                }
            }
        };

        // Expose OllamaSystem globally for audio reactive mode integration
        window.OllamaSystem = OllamaSystem;

        // Toggle Ollama mode
        function toggleOllamaMode() {
            const btn = document.getElementById('ollamaModeBtn');

            if (!OllamaSystem.active) {
                // Activate Ollama mode
                OllamaSystem.active = true;
                OllamaSystem.init();
                OllamaSystem.connect();
                btn.style.background = '#00ff41';
                btn.textContent = 'üåÄ OLLAMA MODE (ON)';
                console.log('üåÄ Ollama Mode: ACTIVATED');
                updateModeButtons('ollama'); // Disable other mode buttons

            } else {
                // Deactivate Ollama mode
                OllamaSystem.active = false;
                OllamaSystem.disconnect();
                btn.style.background = '#00ffff';
                btn.textContent = 'üåÄ OLLAMA MODE';
                console.log('üåÄ Ollama Mode: DEACTIVATED');
                updateModeButtons(null); // Re-enable all buttons
            }
        }

        // Integrate Ollama drawing into main animation loop
        // Wrap drawMatrixRain to include Ollama layer
        const originalDrawMatrixRain = window.drawMatrixRain;
        if (typeof originalDrawMatrixRain !== 'undefined') {
            window.drawMatrixRain = function() {
                // Call original matrix rain drawing
                originalDrawMatrixRain();

                // Draw Ollama message layer on top (same frame, synchronized)
                if (OllamaSystem.active && OllamaSystem.messageActive) {
                    OllamaSystem.drawMessageLayer();
                }
            };
            console.log('üåÄ Ollama System: Integrated into main animation loop');
        }

    </script>
</body>
</html> 
